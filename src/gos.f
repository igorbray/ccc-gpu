      subroutine GOS(Lstart,Lstop) 

C  Calculation of the Born GOS in length and velocity forms     
C  on the shell points generated by CCO program                 
C                                                2              
C         2*omega                        /l L li\               
C   GOS = ----2-- SUM(2L+1)(2l+1)(2li+1) |      |               
C           q      lL                    \0 0 0 /               
C                     |             +  |2                       
C                   x | R(El,i) Ro(i,i)|                        
C                     |  L             |                        
                                                             
      include 'par.f'                                        

      COMMON/channel/ iopen(nchan) !Indicates open channels (=1) 
      COMMON/BORN/ br(0:lamax,kmax,nchan),bv(0:lamax,kmax,nchan)
      COMMON/BORN2r/ Hr(0:lamax,nchan)
      COMMON/BORN2v/ Hv(0:lamax,nchan)
      COMMON /moment/ qq,omega
      dimension nopen(0:lamax,lamax+1)

      dimension psi(maxr)
      complex Hr,Hv

      REAL*8 threej
      character*1 h(0:10) ,nh(0:9)
      data h / 's','p','d','f','g','h','n','o',
     >          'x','x','x'/
      data nh / '0','1','2','3','4','5','6','7','8','9'/
      dimension Tr (0:lamax,lamax+1), Tv (0:lamax,lamax+1)
      dimension Tr1(0:lamax,lamax+1), Tv1(0:lamax,lamax+1)
      dimension GOSR(0:lamax,0:lamax,0:lamax,lamax+1)
      dimension GOSV(0:lamax,0:lamax,0:lamax,lamax+1)
      dimension GOSTR(lamax+1), GOSTV(lamax+1)
      
      GS   =5.807               !He atom GS energy in Ry 
      Ry = 13.6058
      
      CR=4./QQ**2*omega
      CV=4./QQ**2/omega*4

      open(40,file='gos')
      do J=Lstart,Lstop
         open(30+J,file='gos.J='//nh(J))
      end do
      
      write(6,100) QQ,omega*Ry
      write(6,171)              !Title for GOS
      
C Initialization
      
      do la=0,lamax
         do na=1,lamax+1
            Tr(la,na) = 0.
            Tv(la,na) = 0.
            Tr1(la,na) = 0.
            Tv1(la,na) = 0.
         end do
      end do
      
       
      nm = 1
      lm = 0
      do J = Lstart, Lstop     !Monople is excluded. So 1 instead of Lstart
         nch = 0
 10      nchtop = nch
         nch = nch + 1
         call  getchinfo (nch, nt, J, psi, maxpsi, ea, la, na, l)
         if (nch.ne.0) then
            EI = GS + ea
            if (na.gt.nm) nm = na
            if (la.gt.lm) lm = la
            nopen(la,na)=0
            if(iopen(nch).eq.1) nopen(la,na)=1
            write(6,1954) nch,EI,na,h(la),h(l),omega*Ry

            r = abs(Hr(j,nch))**2
            v = abs(Hv(j,nch))**2
            r1 = abs(br(j,1,nch))**2                            
            v1 = abs(bv(j,1,nch))**2                            


*            call IOT3(la,j,l,0,0,0,threej)
*            ang= hat(la)**2 * hat(j)**2 * hat(l)**2 
*            ang=ang * threej**2                                          
            ang= hat(j)**2
            Tr(la,na) = Tr(la,na) + ang*r
            Tv(la,na) = Tv(la,na) + ang*v    
            Tr1(la,na) = Tr1(la,na) + ang*r1
            Tv1(la,na) = Tv1(la,na) + ang*v1    

C Partial GOS

            if(iopen(nch).eq.1) then
               GOSR(J,l,la,na)=ang*r*CR
               GOSV(J,l,la,na)=ang*V*CV
            end if
            go to 10
         end if
      end do
      
C Write partial GOS

      do J=Lstart,Lstop
         if(J.eq.0)then
            write(30+J,'(F7.2,6(E11.4))') Omega*Ry,
     >         GOSR(J,0,0,1),GOSV(J,0,0,1), !1s->Es
     >         GOSR(J,0,0,2),GOSV(J,0,0,2), !2s->Es
     >         GOSR(J,1,1,2),GOSV(J,1,1,2)  !2p->Ep
         else
            write(30+J,'(F7.2,8(E11.4))') Omega*Ry,
     >         GOSR(J,J,0,1),GOSV(J,J,0,1),     !1s->Es
     >         GOSR(J,J,0,2),GOSV(J,J,0,2),     !2s->Es
     >         GOSR(J,J-1,1,2),GOSV(J,J-1,1,2), !2p->EJ-1
     >         GOSR(J,J+1,1,2),GOSV(J,J+1,1,2)  !2p->EJ+1
         end if
      end do


C Sort bound states into n,l
      
      do la=0,lm                
         do na=la+1,nm
            if(nopen(la,na).ne.0)then
               Gr= CR*Tr(la,na)  
               Gv= CV*Tv(la,na)
               Gr1= CR*Tr1(la,na)
               Gv1= CV*Tv1(la,na)
               write(6,200)na,h(la),Gr1,Gv1,Gr,Gv
            end if
         end do
      end do
      write(6,'(A//)')'   '

C Sort bound states into n

      do na=1,nm
         Gr = 0.
         Gv = 0.
         Gr1= 0.
         Gv1= 0.
         do la=0,na-1                
            if(nopen(la,na).ne.0)then
               Gr = Gr+CR*Tr(la,na)  
               Gv = Gv+CV*Tv(la,na)
               Gr1= Gr1+CR*Tr1(la,na)  
               Gv1= Gv1+CV*Tv1(la,na)
            end if
         end do
         write(6,'(A,I1,6(E12.4,1x))')'n=',na,Gr1,Gv1,Gr,Gv

C Total GOS

         GOSTR(na)=Gr
         GOSTV(na)=Gv
      end do
      write(6,'(A//)')'   '
      write(40,'(F7.2,4(E12.4,1x))')
     >   omega*Ry, (GOSTR(na),GOSTV(na), na=1,2)
      
 100  format(///6x,'GENERALIZED OSCILLATOR STRENGTHS at q =',F7.3,
     >    ' w =', F7.2,/   6x,57('-')/ )
 171    FORMAT(/'BOUND',11X,' Coulomb', 12x,'T-matrix integrated'/,
     >          'STATE',
     >    7x,'r',12x,'v',10x,'r',12x,'v',/,54('-')/)
 200  format(I1,A, 2x,12(E11.4,2x))
 1954 format(//11x,'CHANNEL ',I2/,
     >   11x,'Ion energy',F7.3/,
     >   11x,'Bound electron',I2,A1/,
     >   11x,'Free  electron k', A1/,
     >   11x,'Photon energy', F7.2)
      return
      end




