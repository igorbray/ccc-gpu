* this is a (rarely changed) part of posvmat.f

      subroutine gauleg(x1,x2,x,w,n)
      implicit real*8 (a-h,o-z)
c$$$      common/const/pi
      real*8 x1,x2,x(n),w(n),wf(n*2),iwf(n*2)
      parameter (eps=1.d-14)

      pi = acos(-1d0)
      call cgqf(n,x,w,1,0d0,0d0,x1,x2,0,2*n,wf,2*n,iwf,ier)
c$$$      tmp = 0d0
c$$$      do i = 1, n
c$$$         print*,i,x(i),w(i)
c$$$         tmp = tmp + cos(x(i)) * w(i)
c$$$      enddo
c$$$      print*,'Integral from CGQF:',(sin(x2)-sin(x1))/tmp
      if (ier.eq.0) return
      m=(n+1)/2
      xm=0.5d0*(x2+x1)
      xl=0.5d0*(x2-x1)
      do 12 i=1,m
         z=cos(pi*(dble(i)-0.25d0)/(dble(n)+0.5d0))
 1       continue
         p1=1.d0
         p2=0.d0
         do 11 j=1,n
            p3=p2
            p2=p1
            p1=((2.d0*j-1.d0)*z*p2-(dble(j)-1.d0)*p3)/dble(j)
 11      continue
         pp=n*(z*p1-p2)/(z*z-1.d0)
         z1=z
         z=z1-p1/pp
         if(abs(z-z1).gt.eps)go to 1
         x(i)=xm-xl*z
         x(n+1-i)=xm+xl*z
         w(i)=2.d0*xl/((1.d0-z*z)*pp*pp)
         w(n+1-i)=w(i)
 12   continue
c$$$      tmp = 0d0
c$$$      do i = 1, n
c$$$         print*,i,x(i),w(i)
c$$$         tmp = tmp + cos(x(i)) * w(i)
c$$$      enddo
c$$$      print*,'Integral from GAULEG:',
c$$$     >   (sin(x2)-sin(x1))/tmp
      return
      end

*------------------------------------------------------

      subroutine dirvmat(reslam,qb1,qa1,J1,Llb1,Lla1,
     >   lb1,la1,nb1,na1,nbi1,En1,bohr1)

      include 'par.f'
      parameter(limit=100, maxl=2*ltmax+1)
      implicit real*8 (a-h,o-z)
      common/factors/factrl(0:maxl),sqrfct(0:maxl),hat(0:maxl)
      common/input/qb,qa,J,Llb,Lla,lb,la,nb,na,nbi
      common/lambda/lambda,lab2
      common/bohr/bohr
      common/energy/En
c$$$      common/const/pi
      dimension alist(limit),blist(limit),elist(limit),iord(limit),
     >  rlist(limit)
      real flam,w3j1,w3j2,w6j,cof3j,cof6j
      external frb

      qb=qb1
      qa=qa1
      J=J1
      Llb=Llb1
      Lla=Lla1
      lb=lb1
      la=la1
      nb=nb1
      na=na1
      nbi=nbi1
      En=En1
      bohr=bohr1
      
      reslam=0.d0
      lami=max0(iabs(lb-la),iabs(Llb-Lla))
      if(bohr.eq.2.d0.and.(dble(lami/2).eq.dble(lami)/2.d0)) return
      do lam=lami,min0(lb+la,Llb+Lla),2
c      print*,'lam=',lam,lammin,lammax
         flam=float(lam)
         lambda=lam
         w3j1=cof3j(float(la),flam,float(lb),0.,0.,0.)
         w3j2=cof3j(float(Lla),flam,float(Llb),0.,0.,0.)
         w6j=cof6j(float(Lla),flam,float(Llb),
     >      float(lb),float(J),float(la))
c      print*,' w1 w2 w6 =',w3j1,w3j2,w6j
         wigner=w3j1*w3j2*w6j
         if(abs(wigner).lt.1.0d-10) goto 10   !cycle

         a=0.d0
         b=1000.d0
         epsabs=0.d0
         epsrel=1.d-4
         key=6
         call dqage(frb,a,b,epsabs,epsrel,key,limit,result,abserr,
     >      neval,ier,alist,blist,rlist,elist,iord,last)
c     if(ier.ne.0) print*,' dqage: ier=',ier,neval,last
c       print*,' number of evaluations in dirVmat',neval,result
         
         reslam=reslam+wigner*result
 10      continue
      end do
* in a coefficient for dir channel imaginary factor i**(Lla-Llb) is dropped.
      reslam=reslam*hat(Llb)*hat(Lla)*hat(lb)*hat(la)
      reslam=reslam*(-1)**(J+lb+la)
      return
      end


*------------------------------------------------------

      
      real*8 function frb(rb)

      parameter(limit=100)
      implicit real*8 (a-h,o-z)
      common/input/qb,qa,J,Llb,Lla,lb,la,nb,na,nbi
      dimension alist(limit),blist(limit),elist(limit),iord(limit),
     >  rlist(limit)
      common/energy/En
      common/rrbb/rrbb
      common/bohr/bohr
      external fra

      rrbb=rb
      a=0.d0
      b=50.d0

      if(bohr.eq.1.d0) then
         ccc=rb
         qi=sqrt(2.d0*En+1.d0/na/na)
         qf=sqrt(2.d0*En+1.d0/nb/nb)
      else
         ccc=2.d0*rb
         qi=sqrt(4.d0*En+1.d0/na/na)
         qf=sqrt(4.d0*En+1.d0/nb/nb)
      endif

      epsabs=0.d0
      epsrel=1.d-5
      result1=0.d0
      key=5
      if(rb.lt.1.d-3) go to 10
      call dqage(fra,a,ccc,epsabs,epsrel,key,limit,result1,abserr,
     >   neval,ier,alist,blist,rlist,elist,iord,last)
 10   call dqage(fra,ccc,b,epsabs,epsrel,key,limit,result2,abserr,
     >   neval,ier,alist,blist,rlist,elist,iord,last)

      argi=qi*rb
      argf=qf*rb
      call sbessel(argi,Lla,sphbesa)
      call sbessel(argf,Llb,sphbesb)
      frb=(result1+result2)*rb*rb*sphbesa*sphbesb

      return
      end

*------------------------------------------------------

      real*8 function fra(ra)

      implicit real*8 (a-h,o-z)
      common/input/qb,qa,J,Llb,Lla,lb,la,nb,na,nbi
      common/bohr/bohr
      common/lambda/lambda,lab2
      common/rrbb/rb

      if(bohr.eq.1.d0) then
         if(ra.le.rb) then
            rsmall=ra
            rlarge=rb
         else
            rsmall=rb
            rlarge=ra
         endif
         vlam=-(rsmall/rlarge)**lambda/rlarge
         if(lambda.eq.0) vlam=1.d0/rb+vlam

      else

         if(ra.le.(2*rb)) then
            rsmall=ra/2.d0
            rlarge=rb
         else
            rsmall=rb
            rlarge=ra/2.d0
         endif
         vlam=(rsmall/rlarge)**lambda/rlarge
         vlam=(1-(-1)**lambda)*vlam
      endif

      call wfcon(bohr,na,la,ra,radwfa)
      call wfcon(bohr,nb,lb,ra,radwfb)

      fra=radwfa*radwfb*vlam

      return
      end
      
*--------------------------------------------------

      subroutine wfcon(bohr,n,l,r,radwf)

c wave function in configuration space. 1s 2s and 2p.
c radial part of wave functions. u's are used (u=r*R)

      implicit real*8 (a-h,o-z)
      if(n.eq.1) then
         radwf=2.d0/bohr/sqrt(bohr)*r*exp(-r/bohr)
         else if(n.eq.2) then
            radwf=r*exp(-0.5d0*r/bohr)/(2.d0*bohr)**1.5d0
            if(l.eq.0) radwf=radwf*(2.d0-r/bohr)
            if(l.eq.1) radwf=radwf*r/sqrt(3.d0)/bohr
      else
         stop ' conf. space wave functions for n=3 shell are absent'
      end if
      return
      end

*------------------------------------------------------------

      subroutine dqage(f,a,b,epsabs,epsrel,key,limit,result,abserr,
     *   neval,ier,alist,blist,rlist,elist,iord,last)
      implicit real*8 (a-h,o-z)
      external f
      stop 'dqage is missing'
      end

*------------------------------------------------------

      block data chebyshev
c      include 'par.pos'
      double precision x,w
      common/cheb/x(82),w(82)
      data (x(i),w(i),i=1,82)/
     >   5.3372789759515522876d-04,   9.5670321644259061681d-07,
     >   1.7884742067512236950d-03,   5.7688919660736365642d-06,
     >   3.7584472314257305094d-03,   1.7489378792154116998d-05,
     >   6.4406812872353369533d-03,   3.9123311261569520028d-05,
     >   9.8313190351022120253d-03,   7.3605648844132220221d-05,
     >   1.3925510282437763329d-02,   1.2378074815200625011d-04,
     >   1.8717404136883011317d-02,   1.9238293374321713713d-04,
     >   2.4200153731822873029d-02,   2.8201820699520881235d-04,
     >   3.0365924598048658411d-02,   3.9514724964595199949d-04,
     >   3.7205905023986192719d-02,   5.3406985522799742277d-04,
     >   4.4710317985084411753d-02,   7.0091089449520505926d-04,
     >   5.2868434508079694924d-02,   8.9760789277371073699d-04,
     >   6.1668588415596706350d-02,   1.1259002690375164773d-03,
     >   7.1098192421538065402d-02,   1.3873202592264280144d-03,
     >   8.1143755555578801399d-02,   1.6831855205726701177d-03,
     >   9.1790901896852728110d-02,   2.0145933900435900691d-03,
     >   1.0302439059627422631d-01,   2.3824167488744837772d-03,
     >   1.1482813716524764819d-01,   2.7873014268596290891d-03,
     >   1.2718523600634098150d-01,   3.2296650647647761738d-03,
     >   1.4007798415909871514d-01,   3.7096973409748009332d-03,
     >   1.5348790623167379232d-01,   4.2273614592438388967d-03,
     >   1.6739578048644695344d-01,   4.7823967880298797033d-03,
     >   1.8178166604532308245d-01,   5.3743225381575291877d-03,
     >   1.9662493117798274494d-01,   6.0024423641941199628d-03,
     >   2.1190428263404792208d-01,   6.6658497756428578760d-03,
     >   2.2759779597791238186d-01,   7.3634342465305849348d-03,
     >   2.4368294688290250464d-01,   8.0938879158708400543d-03,
     >   2.6013664333948292482d-01,   8.8557127764964652534d-03,
     >   2.7693525873040891987d-01,   9.6472282555781271951d-03,
     >   2.9405466572405715348d-01,   1.0466579096497573586d-02,
     >   3.1147027093563898727d-01,   1.1311743458377136623d-02,
     >   3.2915705030461516424d-01,   1.2180541156260324011d-02,
     >   3.4708958513538493449d-01,   1.3070641971503680105d-02,
     >   3.6524209874721336595d-01,   1.3979573968218830349d-02,
     >   3.8358849367838375299d-01,   1.4904731757464946548d-02,
     >   4.0210238938871343853d-01,   1.5843384656229772641d-02,
     >   4.2075716040384662582d-01,   1.6792684692966906435d-02,
     >   4.3952597484413257050d-01,   1.7749674415510289671d-02,
     >   4.5838183328040784344d-01,   1.8711294460508425609d-02,
     >   4.7729760785862341779d-01,   1.9674390846063278359d-02,
     >   4.9624608163498787861d-01,   2.0635721950977833736d-02,
     >   5.1519998806313431175d-01,   2.1591965144865812691d-02,
     >   5.3413205057475819540d-01,   2.2539723033303800635d-02,
     >   5.5301502219521530584d-01,   2.3475529281143986577d-02,
     >   5.7182172513571133498d-01,   2.4395853974969343156d-02,
     >   5.9052509030395839905d-01,   2.5297108482350095533d-02,
     >   6.0909819667551849259d-01,   2.6175649760902467727d-02,
     >   6.2751431046850170303d-01,   2.7027784063962552325d-02,
     >   6.4574692406484018548d-01,   2.7849769981712901479d-02,
     >   6.6376979462202127898d-01,   2.8637820746500339123d-02,
     >   6.8155698231994001155d-01,   2.9388105718419462714d-02,
     >   6.9908288818842976900d-01,   3.0096750951429251457d-02,
     >   7.1632229146205968024d-01,   3.0759838720560814604d-02,
     >   7.3325038640996101881d-01,   3.1373405866161519521d-02,
     >   7.4984281858977947852d-01,   3.1933440780277933948d-02,
     >   7.6607572047636789776d-01,   3.2435878821437968113d-02,
     >   7.8192574641756466985d-01,   3.2876595894873911645d-02,
     >   7.9737010687138664292d-01,   3.3251399872410492184d-02,
     >   8.1238660188125581003d-01,   3.3556019445416070778d-02,
     >   8.2695365374855023852d-01,   3.3786089899281656577d-02,
     >   8.4105033886492312683d-01,   3.3937135160316880903d-02,
     >   8.5465641867061135627d-01,   3.4004545283638001233d-02,
     >   8.6775236970955664496d-01,   3.3983548306185677674d-02,
     >   8.8031941275787521597d-01,   3.3869175057082383897d-02,
     >   8.9233954100945299817d-01,   3.3656215060485887950d-02,
     >   9.0379554731183024919d-01,   3.3339161027054781078d-02,
     >   9.1467105045800337622d-01,   3.2912138521464829087d-02,
     >   9.2495052055674706961d-01,   3.2368816076963903057d-02,
     >   9.3461930352780883991d-01,   3.1702289080590633990d-02,
     >   9.4366364480251398782d-01,   3.0904927803890700314d-02,
     >   9.5207071236105472715d-01,   2.9968175369101960730d-02,
     >   9.5982861931557753137d-01,   2.8882274093774836780d-02,
     >   9.6692644637208548347d-01,   2.7635886467193392167d-02,
     >   9.7335426470978931513d-01,   2.6215555951673064585d-02,
     >   9.7910316017466946737d-01,   2.4604914630613865168d-02,
     >   9.8416526034478577184d-01,   2.2783471442087659127d-02,
     >   9.8853376733360303912d-01,   2.0724663745738903551d-02,
     >   9.9220300203539463199d-01,   1.8392514897853557016d-02,
     >   9.9516847246727476742d-01,   1.5735380098329784368d-02,
     >   9.9742699917773906126d-01,   1.2672709208054937967d-02,
     >   9.9897701012599778666d-01,   9.0611693396007032474d-03,
     >   9.9981969010918982186d-01,   4.5744237724230892434d-03/

*	82-point chebyshev data
*These data have been obtained with following parameters
*82/82/100/16/16/1

      end block data chebyshev
      
*------------------------------------------------------------

      subroutine coef1(ll,Nl,a,f)
*     table of coefficients for sumk1 polynomial

      real*8 a(20),f(0:20)
      
      select case(ll)
*     20 s states
      case(0)                   ! for s states

      select case(Nl)
      case(1)
         f(0) = a(1)
      case(2) 

         f(0) = a(1)+a(2)
         f(1) = 4*a(2) 

      case(3)
         f(0) = a(1)+a(2)-2*a(3)
         f(1) = 4*a(2)+4*a(3) 

         f(2) = 12*a(3)
      case(4) 

         f(0) = a(1)+a(2)-2*a(3)-2*a(4) 

         f(1) = 4*a(2)+4*a(3)-12*a(4)
         f(2) = 12*a(3)+12*a(4) 

         f(3) = 32*a(4)
      case(5) 

         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+3*a(5) 

         f(1) = 4*a(2)+4*a(3)-12*a(4)-12*a(5) 

         f(2) = 12*a(3)+12*a(4)-48*a(5)
         f(3) = 32*a(4)+32*a(5) 

         f(4) = 80*a(5)
      case(6) 

         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+3*a(5)+3*a(6) 

         f(1) = 4*a(2)+4*a(3)-12*a(4)-12*a(5)+24*a(6) 

         f(2) = 12*a(3)+12*a(4)-48*a(5)-48*a(6) 

         f(3) = 32*a(4)+32*a(5)-160*a(6)
         f(4) = 80*a(5)+80*a(6) 

         f(5) = 192*a(6)
      case(7) 

         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+3*a(5)+3*a(6)-4*a(7) 

         f(1) = 4*a(2)+4*a(3)-12*a(4)-12*a(5)+24*a(6)+24*a(7) 
         
         f(2) = 12*a(3)+12*a(4)-48*a(5)-48*a(6)+120*a(7) 
         
         f(3) = 32*a(4)+32*a(5)-160*a(6)-160*a(7) 

         f(4) = 80*a(5)+80*a(6)-480*a(7)
         f(5) = 192*a(6)+192*a(7) 

         f(6) = 448*a(7)
      case(8) 
         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+3*a(5)+3*a(6)-4*a(7)-
     >      4*a(8)
         f(1) = 4*a(2)+4*a(3)-12*a(4)-12*a(5)+24*a(6)+
     >      24*a(7)-40*a(8)
         f(2) = 
     >      12*a(3)+12*a(4)-48*a(5)-48*a(6)+120*a(7)+120*a(8) 

         f(3) = 32*a(4)+32*a(5)-160*a(6)-160*a(7)+480*a(8) 

         f(4) = 80*a(5)+80*a(6)-480*a(7)-480*a(8) 

         f(5) = 192*a(6)+192*a(7)-1344*a(8) 

         f(6) = 448*a(7)+448*a(8)
         f(7) = 1024*a(8) 

      case(9)
         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+3*a(5)+3*a(6)-
     >      4*a(7)-4*a(8)+5*a(9) 

         f(1) = 4*a(2)+4*a(3)-12*a(4)-12*a(5)+24*a(6)+24*a(7)-
     >      40*a(8)-40*a(9)
         f(2) = 
     >      12*a(3)+12*a(4)-48*a(5)-48*a(6)+120*a(7)+120*a(8)-240*a(9)

         f(3) = 32*a(4)+32*a(5)-160*a(6)-160*a(7)+480*a(8)+480*a(9) 

         f(4) = 80*a(5)+80*a(6)-480*a(7)-480*a(8)+1680*a(9) 

         f(5) = 192*a(6)+192*a(7)-1344*a(8)-1344*a(9) 

         f(6) = 448*a(7)+448*a(8)-3584*a(9) 

         f(7) = 1024*a(8)+1024*a(9)
         f(8) = 2304*a(9) 

      case(10)
         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+3*a(5)+3*a(6)-
     >      4*a(7)-4*a(8)+5*a(9)+5*a(10) 

         f(1) = 4*a(2)+4*a(3)-12*a(4)-12*a(5)+24*a(6)+24*a(7)-
     >      40*a(8)-40*a(9)+60*a(10) 

         f(2) = 12*a(3)+12*a(4)-48*a(5)-48*a(6)+120*a(7)+120*a(8)-
     >      240*a(9)-240*a(10)
         f(3) = 
     >      32*a(4)+32*a(5)-160*a(6)-160*a(7)+480*a(8)+480*a(9)-
     >      1120*a(10)
         f(4) = 80*a(5)+80*a(6)-480*a(7)-480*a(8)+
     >      1680*a(9)+1680*a(10) 

         f(5) = 192*a(6)+192*a(7)-1344*a(8)-1344*a(9)+5376*a(10) 

         f(6) = 448*a(7)+448*a(8)-3584*a(9)-3584*a(10) 

         f(7) = 1024*a(8)+1024*a(9)-9216*a(10) 

         f(8) = 2304*a(9)+2304*a(10)
         f(9) = 5120*a(10) 

      case(11)
         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+3*a(5)+3*a(6)-
     >      4*a(7)-4*a(8)+5*a(9)+5*a(10)-6*a(11) 

         f(1) = 4*a(2)+4*a(3)-12*a(4)-12*a(5)+24*a(6)+24*a(7)-
     >      40*a(8)-40*a(9)+60*a(10)+60*a(11) 

         f(2) = 12*a(3)+12*a(4)-48*a(5)-48*a(6)+120*a(7)+120*a(8)-
     >      240*a(9)-240*a(10)+420*a(11) 

         f(3) = 32*a(4)+32*a(5)-160*a(6)-160*a(7)+480*a(8)+
     >      480*a(9)-1120*a(10)-1120*a(11) 

         f(4) = 80*a(5)+80*a(6)-480*a(7)-480*a(8)+1680*a(9)+
     >      1680*a(10)-4480*a(11) 

         f(5) = 192*a(6)+192*a(7)-1344*a(8)-1344*a(9)+5376*a(10)+
     >      5376*a(11)
         f(6) = 448*a(7)+448*a(8)-3584*a(9)-3584*a(10)+
     >      16128*a(11)
         f(7) = 1024*a(8)+1024*a(9)-9216*a(10)-
     >      9216*a(11)
         f(8) = 2304*a(9)+2304*a(10)-23040*a(11) 

         f(9) = 5120*a(10)+5120*a(11)
         f(10) = 11264*a(11) 

      case(12)
         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+3*a(5)+3*a(6)-
     >      4*a(7)-4*a(8)+5*a(9)+5*a(10)-6*a(11)-6*a(12) 

         f(1) = 4*a(2)+4*a(3)-12*a(4)-12*a(5)+24*a(6)+24*a(7)-
     >      40*a(8)-40*a(9)+60*a(10)+60*a(11)-84*a(12) 

         f(2) = 12*a(3)+12*a(4)-48*a(5)-48*a(6)+120*a(7)+120*a(8)-
     >      240*a(9)-240*a(10)+420*a(11)+420*a(12) 

         f(3) = 32*a(4)+32*a(5)-160*a(6)-160*a(7)+480*a(8)+
     >      480*a(9)-1120*a(10)-1120*a(11)+2240*a(12) 

         f(4) = 80*a(5)+80*a(6)-480*a(7)-480*a(8)+1680*a(9)+
     >      1680*a(10)-4480*a(11)-4480*a(12) 

         f(5) = 192*a(6)+192*a(7)-1344*a(8)-1344*a(9)+5376*a(10)+
     >      5376*a(11)-16128*a(12) 

         f(6) = 448*a(7)+448*a(8)-3584*a(9)-3584*a(10)+16128*a(11)+
     >      16128*a(12)
         f(7) = 1024*a(8)+1024*a(9)-9216*a(10)-
     >      9216*a(11)+46080*a(12) 

         f(8) = 2304*a(9)+2304*a(10)-23040*a(11)-23040*a(12) 

         f(9) = 5120*a(10)+5120*a(11)-56320*a(12) 

         f(10) = 11264*a(11)+11264*a(12)
         f(11) = 24576*a(12) 

      case(13)
         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+3*a(5)+3*a(6)-
     >      4*a(7)-4*a(8)+5*a(9)+5*a(10)-6*a(11)-6*a(12)+7*a(13) 

         f(1) = 4*a(2)+4*a(3)-12*a(4)-12*a(5)+24*a(6)+24*a(7)-
     >      40*a(8)-40*a(9)+60*a(10)+60*a(11)-84*a(12)-84*a(13) 

         f(2) = 12*a(3)+12*a(4)-48*a(5)-48*a(6)+120*a(7)+120*a(8)-
     >      240*a(9)-240*a(10)+420*a(11)+420*a(12)-672*a(13) 

         f(3) = 32*a(4)+32*a(5)-160*a(6)-160*a(7)+480*a(8)+
     >      480*a(9)-1120*a(10)-1120*a(11)+2240*a(12)+2240*a(13) 

         f(4) = 80*a(5)+80*a(6)-480*a(7)-480*a(8)+1680*a(9)+
     >      1680*a(10)-4480*a(11)-4480*a(12)+10080*a(13) 

         f(5) = 192*a(6)+192*a(7)-1344*a(8)-1344*a(9)+5376*a(10)+
     >      5376*a(11)-16128*a(12)-16128*a(13) 

         f(6) = 448*a(7)+448*a(8)-3584*a(9)-3584*a(10)+16128*a(11)+
     >      16128*a(12)-53760*a(13) 

         f(7) = 1024*a(8)+1024*a(9)-9216*a(10)-9216*a(11)+
     >      46080*a(12)+46080*a(13) 

         f(8) = 2304*a(9)+2304*a(10)-23040*a(11)-23040*a(12)+
     >      126720*a(13)
         f(9) = 
     >      5120*a(10)+5120*a(11)-56320*a(12)-56320*a(13) 

         f(10) = 11264*a(11)+11264*a(12)-135168*a(13) 

         f(11) = 24576*a(12)+24576*a(13)
         f(12) = 53248*a(13) 

      case(14)
         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+3*a(5)+3*a(6)-
     >      4*a(7)-4*a(8)+5*a(9)+5*a(10)-6*a(11)-6*a(12)+7*a(13)+
     >      7*a(14)
         f(1) = 4*a(2)+4*a(3)-12*a(4)-12*a(5)+24*a(6)+
     >      24*a(7)-40*a(8)-40*a(9)+60*a(10)+60*a(11)-84*a(12)-
     >      84*a(13)+112*a(14)
         f(2) = 
     >      12*a(3)+12*a(4)-48*a(5)-48*a(6)+120*a(7)+120*a(8)-
     >      240*a(9)-240*a(10)+420*a(11)+420*a(12)-672*a(13)-672*a(14) 

         f(3) = 32*a(4)+32*a(5)-160*a(6)-160*a(7)+480*a(8)+
     >      480*a(9)-1120*a(10)-1120*a(11)+2240*a(12)+2240*a(13)-
     >      4032*a(14)
         f(4) = 80*a(5)+80*a(6)-480*a(7)-480*a(8)+
     >      1680*a(9)+1680*a(10)-4480*a(11)-4480*a(12)+10080*a(13)+
     >      10080*a(14)
         f(5) = 192*a(6)+192*a(7)-1344*a(8)-1344*a(9)+
     >      5376*a(10)+5376*a(11)-16128*a(12)-16128*a(13)+40320*a(14) 

         f(6) = 448*a(7)+448*a(8)-3584*a(9)-3584*a(10)+16128*a(11)+
     >      16128*a(12)-53760*a(13)-53760*a(14) 

         f(7) = 1024*a(8)+1024*a(9)-9216*a(10)-9216*a(11)+
     >      46080*a(12)+46080*a(13)-168960*a(14) 

         f(8) = 2304*a(9)+2304*a(10)-23040*a(11)-23040*a(12)+
     >      126720*a(13)+126720*a(14) 

         f(9) = 5120*a(10)+5120*a(11)-56320*a(12)-56320*a(13)+
     >      337920*a(14)
         f(10) = 
     >      11264*a(11)+11264*a(12)-135168*a(13)-135168*a(14) 

         f(11) = 24576*a(12)+24576*a(13)-319488*a(14) 

         f(12) = 53248*a(13)+53248*a(14)
         f(13) = 114688*a(14) 

      case(15)
         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+3*a(5)+3*a(6)-
     >      4*a(7)-4*a(8)+5*a(9)+5*a(10)-6*a(11)-6*a(12)+7*a(13)+
     >      7*a(14)-8*a(15)
         f(1) = 
     >      4*a(2)+4*a(3)-12*a(4)-12*a(5)+24*a(6)+24*a(7)-40*a(8)-
     >      40*a(9)+60*a(10)+60*a(11)-84*a(12)-84*a(13)+112*a(14)+
     >      112*a(15)
         f(2) = 12*a(3)+12*a(4)-48*a(5)-48*a(6)+
     >      120*a(7)+120*a(8)-240*a(9)-240*a(10)+420*a(11)+420*a(12)-
     >      672*a(13)-672*a(14)+1008*a(15) 

         f(3) = 32*a(4)+32*a(5)-160*a(6)-160*a(7)+480*a(8)+
     >      480*a(9)-1120*a(10)-1120*a(11)+2240*a(12)+2240*a(13)-
     >      4032*a(14)-4032*a(15) 

         f(4) = 80*a(5)+80*a(6)-480*a(7)-480*a(8)+1680*a(9)+
     >      1680*a(10)-4480*a(11)-4480*a(12)+10080*a(13)+10080*a(14)-
     >      20160*a(15)
         f(5) = 192*a(6)+192*a(7)-1344*a(8)-1344*a(9)+
     >      5376*a(10)+5376*a(11)-16128*a(12)-16128*a(13)+40320*a(14)+
     >      40320*a(15)
         f(6) = 448*a(7)+448*a(8)-3584*a(9)-
     >      3584*a(10)+16128*a(11)+16128*a(12)-53760*a(13)-53760*a(14)+
     >      147840*a(15)
         f(7) = 
     >      1024*a(8)+1024*a(9)-9216*a(10)-9216*a(11)+46080*a(12)+
     >      46080*a(13)-168960*a(14)-168960*a(15) 

         f(8) = 2304*a(9)+2304*a(10)-23040*a(11)-23040*a(12)+
     >      126720*a(13)+126720*a(14)-506880*a(15) 

         f(9) = 5120*a(10)+5120*a(11)-56320*a(12)-56320*a(13)+
     >      337920*a(14)+337920*a(15) 

         f(10) = 11264*a(11)+11264*a(12)-135168*a(13)-135168*a(14)+
     >      878592*a(15)
         f(11) = 
     >      24576*a(12)+24576*a(13)-319488*a(14)-319488*a(15) 

         f(12) = 53248*a(13)+53248*a(14)-745472*a(15) 

         f(13) = 114688*a(14)+114688*a(15)
         f(14) = 245760*a(15) 

      case(16)
         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+3*a(5)+3*a(6)-
     >      4*a(7)-4*a(8)+5*a(9)+5*a(10)-6*a(11)-6*a(12)+7*a(13)+
     >      7*a(14)-8*a(15)-8*a(16) 

         f(1) = 4*a(2)+4*a(3)-12*a(4)-12*a(5)+24*a(6)+24*a(7)-
     >      40*a(8)-40*a(9)+60*a(10)+60*a(11)-84*a(12)-84*a(13)+
     >      112*a(14)+112*a(15)-144*a(16) 

         f(2) = 12*a(3)+12*a(4)-48*a(5)-48*a(6)+120*a(7)+120*a(8)-
     >      240*a(9)-240*a(10)+420*a(11)+420*a(12)-672*a(13)-
     >      672*a(14)+1008*a(15)+1008*a(16) 

         f(3) = 32*a(4)+32*a(5)-160*a(6)-160*a(7)+480*a(8)+
     >      480*a(9)-1120*a(10)-1120*a(11)+2240*a(12)+2240*a(13)-
     >      4032*a(14)-4032*a(15)+6720*a(16) 

         f(4) = 80*a(5)+80*a(6)-480*a(7)-480*a(8)+1680*a(9)+
     >      1680*a(10)-4480*a(11)-4480*a(12)+10080*a(13)+10080*a(14)-
     >      20160*a(15)-20160*a(16) 

         f(5) = 192*a(6)+192*a(7)-1344*a(8)-1344*a(9)+5376*a(10)+
     >      5376*a(11)-16128*a(12)-16128*a(13)+40320*a(14)+40320*a(15)-
     >      88704*a(16)
         f(6) = 448*a(7)+448*a(8)-3584*a(9)-
     >      3584*a(10)+16128*a(11)+16128*a(12)-53760*a(13)-53760*a(14)+
     >      147840*a(15)+147840*a(16) 

         f(7) = 1024*a(8)+1024*a(9)-9216*a(10)-9216*a(11)+
     >      46080*a(12)+46080*a(13)-168960*a(14)-168960*a(15)
     >      +506880*a(16)

         f(8) = 2304*a(9)+2304*a(10)-23040*a(11)-23040*a(12)+
     >      126720*a(13)+126720*a(14)-506880*a(15)-506880*a(16) 

         f(9) = 5120*a(10)+5120*a(11)-56320*a(12)-56320*a(13)+
     >      337920*a(14)+337920*a(15)-1464320*a(16) 

         f(10) = 11264*a(11)+11264*a(12)-135168*a(13)-135168*a(14)+
     >      878592*a(15)+878592*a(16) 

         f(11) = 24576*a(12)+24576*a(13)-319488*a(14)-319488*a(15)+
     >      2236416*a(16)
         f(12) = 
     >      53248*a(13)+53248*a(14)-745472*a(15)-745472*a(16) 

         f(13) = 114688*a(14)+114688*a(15)-1720320*a(16) 

         f(14) = 245760*a(15)+245760*a(16)
         f(15) = 524288*a(16) 

      case(17)
         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+3*a(5)+3*a(6)-
     >      4*a(7)-4*a(8)+5*a(9)+5*a(10)-6*a(11)-6*a(12)+7*a(13)+
     >      7*a(14)-8*a(15)-8*a(16)+9*a(17) 

         f(1) = 4*a(2)+4*a(3)-12*a(4)-12*a(5)+24*a(6)+24*a(7)-
     >      40*a(8)-40*a(9)+60*a(10)+60*a(11)-84*a(12)-84*a(13)+
     >      112*a(14)+112*a(15)-144*a(16)-144*a(17) 

         f(2) = 12*a(3)+12*a(4)-48*a(5)-48*a(6)+120*a(7)+120*a(8)-
     >      240*a(9)-240*a(10)+420*a(11)+420*a(12)-672*a(13)-
     >      672*a(14)+1008*a(15)+1008*a(16)-1440*a(17) 

         f(3) = 32*a(4)+32*a(5)-160*a(6)-160*a(7)+480*a(8)+
     >      480*a(9)-1120*a(10)-1120*a(11)+2240*a(12)+2240*a(13)-
     >      4032*a(14)-4032*a(15)+6720*a(16)+6720*a(17) 

         f(4) = 80*a(5)+80*a(6)-480*a(7)-480*a(8)+1680*a(9)+
     >      1680*a(10)-4480*a(11)-4480*a(12)+10080*a(13)+10080*a(14)-
     >      20160*a(15)-20160*a(16)+36960*a(17) 

         f(5) = 192*a(6)+192*a(7)-1344*a(8)-1344*a(9)+5376*a(10)+
     >      5376*a(11)-16128*a(12)-16128*a(13)+40320*a(14)+40320*a(15)-
     >      88704*a(16)-88704*a(17) 

         f(6) = 448*a(7)+448*a(8)-3584*a(9)-3584*a(10)+16128*a(11)+
     >      16128*a(12)-53760*a(13)-53760*a(14)+147840*a(15)+
     >      147840*a(16)-354816*a(17) 

         f(7) = 1024*a(8)+1024*a(9)-9216*a(10)-9216*a(11)+
     >      46080*a(12)+46080*a(13)-168960*a(14)-168960*a(15)+
     >      506880*a(16)+506880*a(17) 

         f(8) = 2304*a(9)+2304*a(10)-23040*a(11)-23040*a(12)+
     >      126720*a(13)+126720*a(14)-506880*a(15)-506880*a(16)+
     >      1647360*a(17)
         f(9) = 
     >      5120*a(10)+5120*a(11)-56320*a(12)-56320*a(13)+337920*a(14)+
     >      337920*a(15)-1464320*a(16)-1464320*a(17) 

         f(10) = 11264*a(11)+11264*a(12)-135168*a(13)-135168*a(14)+
     >      878592*a(15)+878592*a(16)-4100096*a(17) 

         f(11) = 24576*a(12)+24576*a(13)-319488*a(14)-319488*a(15)+
     >      2236416*a(16)+2236416*a(17) 

         f(12) = 53248*a(13)+53248*a(14)-745472*a(15)-745472*a(16)+
     >      5591040*a(17)
         f(13) = 
     >      114688*a(14)+114688*a(15)-1720320*a(16)-1720320*a(17) 

         f(14) = 245760*a(15)+245760*a(16)-3932160*a(17) 

         f(15) = 524288*a(16)+524288*a(17)
         f(16) = 1114112*a(17) 

      case(18)
         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+3*a(5)+3*a(6)-
     >      4*a(7)-4*a(8)+5*a(9)+5*a(10)-6*a(11)-6*a(12)+7*a(13)+
     >      7*a(14)-8*a(15)-8*a(16)+9*a(17)+9*a(18) 

         f(1) = 4*a(2)+4*a(3)-12*a(4)-12*a(5)+24*a(6)+24*a(7)-
     >      40*a(8)-40*a(9)+60*a(10)+60*a(11)-84*a(12)-84*a(13)+
     >      112*a(14)+112*a(15)-144*a(16)-144*a(17)+180*a(18) 

         f(2) = 12*a(3)+12*a(4)-48*a(5)-48*a(6)+120*a(7)+120*a(8)-
     >      240*a(9)-240*a(10)+420*a(11)+420*a(12)-672*a(13)-
     >      672*a(14)+1008*a(15)+1008*a(16)-1440*a(17)-1440*a(18) 

         f(3) = 32*a(4)+32*a(5)-160*a(6)-160*a(7)+480*a(8)+
     >      480*a(9)-1120*a(10)-1120*a(11)+2240*a(12)+2240*a(13)-
     >      4032*a(14)-4032*a(15)+6720*a(16)+6720*a(17)-10560*a(18) 

         f(4) = 80*a(5)+80*a(6)-480*a(7)-480*a(8)+1680*a(9)+
     >      1680*a(10)-4480*a(11)-4480*a(12)+10080*a(13)+10080*a(14)-
     >      20160*a(15)-20160*a(16)+36960*a(17)+36960*a(18) 

         f(5) = 192*a(6)+192*a(7)-1344*a(8)-1344*a(9)+5376*a(10)+
     >      5376*a(11)-16128*a(12)-16128*a(13)+40320*a(14)+40320*a(15)-
     >      88704*a(16)-88704*a(17)+177408*a(18) 

         f(6) = 448*a(7)+448*a(8)-3584*a(9)-3584*a(10)+16128*a(11)+
     >      16128*a(12)-53760*a(13)-53760*a(14)+147840*a(15)+
     >      147840*a(16)-354816*a(17)-354816*a(18) 

         f(7) = 1024*a(8)+1024*a(9)-9216*a(10)-9216*a(11)+
     >      46080*a(12)+46080*a(13)-168960*a(14)-168960*a(15)+
     >      506880*a(16)+506880*a(17)-1317888*a(18) 

         f(8) = 2304*a(9)+2304*a(10)-23040*a(11)-23040*a(12)+
     >      126720*a(13)+126720*a(14)-506880*a(15)-506880*a(16)+
     >      1647360*a(17)+1647360*a(18) 

         f(9) = 5120*a(10)+5120*a(11)-56320*a(12)-56320*a(13)+
     >      337920*a(14)+337920*a(15)-1464320*a(16)-1464320*a(17)+
     >      5125120*a(18)
         f(10) = 
     >      11264*a(11)+11264*a(12)-135168*a(13)-135168*a(14)+
     >      878592*a(15)+878592*a(16)-4100096*a(17)-4100096*a(18) 

         f(11) = 24576*a(12)+24576*a(13)-319488*a(14)-319488*a(15)+
     >      2236416*a(16)+2236416*a(17)-11182080*a(18) 

         f(12) = 53248*a(13)+53248*a(14)-745472*a(15)-745472*a(16)+
     >      5591040*a(17)+5591040*a(18) 

         f(13) = 114688*a(14)+114688*a(15)-1720320*a(16)-
     >      1720320*a(17)+13762560*a(18) 

         f(14) = 245760*a(15)+245760*a(16)-3932160*a(17)-3932160*a(18) 

         f(15) = 524288*a(16)+524288*a(17)-8912896*a(18) 

         f(16) = 1114112*a(17)+1114112*a(18)
         f(17) = 2359296*a(18) 

      case(19)
         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+3*a(5)+3*a(6)-
     >      4*a(7)-4*a(8)+5*a(9)+5*a(10)-6*a(11)-6*a(12)+7*a(13)+
     >      7*a(14)-8*a(15)-8*a(16)+9*a(17)+9*a(18)-10*a(19) 

         f(1) = 4*a(2)+4*a(3)-12*a(4)-12*a(5)+24*a(6)+24*a(7)-
     >      40*a(8)-40*a(9)+60*a(10)+60*a(11)-84*a(12)-84*a(13)+
     >      112*a(14)+112*a(15)-144*a(16)-144*a(17)+180*a(18)+180*a(19)

         f(2) = 12*a(3)+12*a(4)-48*a(5)-48*a(6)+120*a(7)+120*a(8)-
     >      240*a(9)-240*a(10)+420*a(11)+420*a(12)-672*a(13)-
     >      672*a(14)+1008*a(15)+1008*a(16)-1440*a(17)-1440*a(18)+
     >      1980*a(19)
         f(3) = 32*a(4)+32*a(5)-160*a(6)-160*a(7)+
     >      480*a(8)+480*a(9)-1120*a(10)-1120*a(11)+2240*a(12)+
     >      2240*a(13)-4032*a(14)-4032*a(15)+6720*a(16)+6720*a(17)-
     >      10560*a(18)-10560*a(19) 

         f(4) = 80*a(5)+80*a(6)-480*a(7)-480*a(8)+1680*a(9)+
     >      1680*a(10)-4480*a(11)-4480*a(12)+10080*a(13)+10080*a(14)-
     >      20160*a(15)-20160*a(16)+36960*a(17)+36960*a(18)-63360*a(19) 

         f(5) = 192*a(6)+192*a(7)-1344*a(8)-1344*a(9)+5376*a(10)+
     >      5376*a(11)-16128*a(12)-16128*a(13)+40320*a(14)+40320*a(15)-
     >      88704*a(16)-88704*a(17)+177408*a(18)+177408*a(19) 

         f(6) = 448*a(7)+448*a(8)-3584*a(9)-3584*a(10)+16128*a(11)+
     >      16128*a(12)-53760*a(13)-53760*a(14)+147840*a(15)+
     >      147840*a(16)-354816*a(17)-354816*a(18)+768768*a(19) 

         f(7) = 1024*a(8)+1024*a(9)-9216*a(10)-9216*a(11)+
     >      46080*a(12)+46080*a(13)-168960*a(14)-168960*a(15)+
     >      506880*a(16)+506880*a(17)-1317888*a(18)-1317888*a(19) 

         f(8) = 2304*a(9)+2304*a(10)-23040*a(11)-23040*a(12)+
     >      126720*a(13)+126720*a(14)-506880*a(15)-506880*a(16)+
     >      1647360*a(17)+1647360*a(18)-4612608*a(19) 

         f(9) = 5120*a(10)+5120*a(11)-56320*a(12)-56320*a(13)+
     >      337920*a(14)+337920*a(15)-1464320*a(16)-1464320*a(17)+
     >      5125120*a(18)+5125120*a(19) 

         f(10) = 11264*a(11)+11264*a(12)-135168*a(13)-135168*a(14)+
     >      878592*a(15)+878592*a(16)-4100096*a(17)-4100096*a(18)+
     >      15375360*a(19)
         f(11) = 
     >      24576*a(12)+24576*a(13)-319488*a(14)-319488*a(15)+
     >      2236416*a(16)+2236416*a(17)-11182080*a(18)-11182080*a(19) 

         f(12) = 53248*a(13)+53248*a(14)-745472*a(15)-745472*a(16)+
     >      5591040*a(17)+5591040*a(18)-29818880*a(19) 

         f(13) = 114688*a(14)+114688*a(15)-1720320*a(16)-
     >      1720320*a(17)+13762560*a(18)+13762560*a(19) 

         f(14) = 245760*a(15)+245760*a(16)-3932160*a(17)-
     >      3932160*a(18)+33423360*a(19) 

         f(15) = 524288*a(16)+524288*a(17)-8912896*a(18)-8912896*a(19) 

         f(16) = 1114112*a(17)+1114112*a(18)-20054016*a(19) 

         f(17) = 2359296*a(18)+2359296*a(19)
         f(18) = 4980736*a(19) 

      case(20)
         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+3*a(5)+3*a(6)-
     >      4*a(7)-4*a(8)+5*a(9)+5*a(10)-6*a(11)-6*a(12)+7*a(13)+
     >      7*a(14)-8*a(15)-8*a(16)+9*a(17)+9*a(18)-10*a(19)-10*a(20) 

         f(1) = 4*a(2)+4*a(3)-12*a(4)-12*a(5)+24*a(6)+24*a(7)-
     >      40*a(8)-40*a(9)+60*a(10)+60*a(11)-84*a(12)-84*a(13)+
     >      112*a(14)+112*a(15)-144*a(16)-144*a(17)+180*a(18)+
     >      180*a(19)-220*a(20)
         f(2) = 
     >      12*a(3)+12*a(4)-48*a(5)-48*a(6)+120*a(7)+120*a(8)-
     >      240*a(9)-240*a(10)+420*a(11)+420*a(12)-672*a(13)-672*a(14)+
     >      1008*a(15)+1008*a(16)-1440*a(17)-1440*a(18)+1980*a(19)+
     >      1980*a(20)
         f(3) = 32*a(4)+32*a(5)-160*a(6)-160*a(7)+
     >      480*a(8)+480*a(9)-1120*a(10)-1120*a(11)+2240*a(12)+
     >      2240*a(13)-4032*a(14)-4032*a(15)+6720*a(16)+6720*a(17)-
     >      10560*a(18)-10560*a(19)+15840*a(20) 

         f(4) = 80*a(5)+80*a(6)-480*a(7)-480*a(8)+1680*a(9)+
     >      1680*a(10)-4480*a(11)-4480*a(12)+10080*a(13)+10080*a(14)-
     >      20160*a(15)-20160*a(16)+36960*a(17)+36960*a(18)-63360*a(19)-
     >      63360*a(20)
         f(5) = 192*a(6)+192*a(7)-1344*a(8)-1344*a(9)+
     >      5376*a(10)+5376*a(11)-16128*a(12)-16128*a(13)+40320*a(14)+
     >      40320*a(15)-88704*a(16)-88704*a(17)+177408*a(18)+
     >      177408*a(19)-329472*a(20) 

         f(6) = 448*a(7)+448*a(8)-3584*a(9)-3584*a(10)+16128*a(11)+
     >      16128*a(12)-53760*a(13)-53760*a(14)+147840*a(15)+
     >      147840*a(16)-354816*a(17)-354816*a(18)+768768*a(19)+
     >      768768*a(20)
         f(7) = 
     >      1024*a(8)+1024*a(9)-9216*a(10)-9216*a(11)+46080*a(12)+
     >      46080*a(13)-168960*a(14)-168960*a(15)+506880*a(16)+
     >      506880*a(17)-1317888*a(18)-1317888*a(19)+3075072*a(20) 

         f(8) = 2304*a(9)+2304*a(10)-23040*a(11)-23040*a(12)+
     >      126720*a(13)+126720*a(14)-506880*a(15)-506880*a(16)+
     >      1647360*a(17)+1647360*a(18)-4612608*a(19)-4612608*a(20) 

         f(9) = 5120*a(10)+5120*a(11)-56320*a(12)-56320*a(13)+
     >      337920*a(14)+337920*a(15)-1464320*a(16)-1464320*a(17)+
     >      5125120*a(18)+5125120*a(19)-15375360*a(20) 

         f(10) = 11264*a(11)+11264*a(12)-135168*a(13)-135168*a(14)+
     >      878592*a(15)+878592*a(16)-4100096*a(17)-4100096*a(18)+
     >      15375360*a(19)+15375360*a(20) 

         f(11) = 24576*a(12)+24576*a(13)-319488*a(14)-319488*a(15)+
     >      2236416*a(16)+2236416*a(17)-11182080*a(18)-11182080*a(19)+
     >      44728320*a(20)
         f(12) = 
     >      53248*a(13)+53248*a(14)-745472*a(15)-745472*a(16)+
     >      5591040*a(17)+5591040*a(18)-29818880*a(19)-29818880*a(20) 

         f(13) = 114688*a(14)+114688*a(15)-1720320*a(16)-1720320*a(17)+
     >      13762560*a(18)+13762560*a(19)-77987840*a(20) 

         f(14) = 245760*a(15)+245760*a(16)-3932160*a(17)-3932160*a(18)+
     >      33423360*a(19)+33423360*a(20) 

         f(15) = 524288*a(16)+524288*a(17)-8912896*a(18)-8912896*a(19)+
     >      80216064*a(20)
         f(16) = 
     >      1114112*a(17)+1114112*a(18)-20054016*a(19)-20054016*a(20) 

         f(17) = 2359296*a(18)+2359296*a(19)-44826624*a(20) 

         f(18) = 4980736*a(19)+4980736*a(20)
         f(19) = 10485760*a(20)

      case default
         stop ' coef1: statement is missing for Nl>20 at l=0'
      end select
      
*     15 p states
      case(1)                   ! for p states
      select case(Nl)

      case(1)
         f(0) = 2*a(1) 

      case(2)
         f(0) = 2*a(1)+2*a(2)
         f(1) = 12*a(2) 

      case(3)
         f(0) = 2*a(1)+2*a(2)-6*a(3) 

         f(1) = 12*a(2)+12*a(3)
         f(2) = 48*a(3) 

      case(4)
         f(0) = 2*a(1)+2*a(2)-6*a(3)-6*a(4) 

         f(1) = 12*a(2)+12*a(3)-48*a(4)
         f(2) = 48*a(3)+48*a(4) 

         f(3) = 160*a(4)
      case(5) 

         f(0) = 2*a(1)+2*a(2)-6*a(3)-6*a(4)+12*a(5) 

         f(1) = 12*a(2)+12*a(3)-48*a(4)-48*a(5) 

         f(2) = 48*a(3)+48*a(4)-240*a(5)
         f(3) = 160*a(4)+160*a(5) 

         f(4) = 480*a(5)
      case(6) 

         f(0) = 2*a(1)+2*a(2)-6*a(3)-6*a(4)+12*a(5)+12*a(6) 

         f(1) = 12*a(2)+12*a(3)-48*a(4)-48*a(5)+120*a(6) 

         f(2) = 48*a(3)+48*a(4)-240*a(5)-240*a(6) 

         f(3) = 160*a(4)+160*a(5)-960*a(6) 

         f(4) = 480*a(5)+480*a(6)
         f(5) = 1344*a(6) 

      case(7)
         f(0) = 2*a(1)+2*a(2)-6*a(3)-6*a(4)+12*a(5)+
     >      12*a(6)-20*a(7)
         f(1) = 
     >      12*a(2)+12*a(3)-48*a(4)-48*a(5)+120*a(6)+120*a(7) 

         f(2) = 48*a(3)+48*a(4)-240*a(5)-240*a(6)+720*a(7) 

         f(3) = 160*a(4)+160*a(5)-960*a(6)-960*a(7) 

         f(4) = 480*a(5)+480*a(6)-3360*a(7) 

         f(5) = 1344*a(6)+1344*a(7)
         f(6) = 3584*a(7) 

      case(8)
         f(0) = 2*a(1)+2*a(2)-6*a(3)-6*a(4)+12*a(5)+
     >      12*a(6)-20*a(7)-20*a(8) 

         f(1) = 12*a(2)+12*a(3)-48*a(4)-48*a(5)+120*a(6)+120*a(7)-
     >      240*a(8)
         f(2) = 48*a(3)+48*a(4)-240*a(5)-240*a(6)+
     >      720*a(7)+720*a(8)
         f(3) = 
     >      160*a(4)+160*a(5)-960*a(6)-960*a(7)+3360*a(8) 

         f(4) = 480*a(5)+480*a(6)-3360*a(7)-3360*a(8) 

         f(5) = 1344*a(6)+1344*a(7)-10752*a(8) 

         f(6) = 3584*a(7)+3584*a(8)
         f(7) = 9216*a(8) 

      case(9)
         f(0) = 2*a(1)+2*a(2)-6*a(3)-6*a(4)+12*a(5)+
     >      12*a(6)-20*a(7)-20*a(8)+30*a(9) 

         f(1) = 12*a(2)+12*a(3)-48*a(4)-48*a(5)+120*a(6)+120*a(7)-
     >      240*a(8)-240*a(9)
         f(2) = 
     >      48*a(3)+48*a(4)-240*a(5)-240*a(6)+720*a(7)+720*a(8)-
     >      1680*a(9)
         f(3) = 160*a(4)+160*a(5)-960*a(6)-960*a(7)+
     >      3360*a(8)+3360*a(9)
         f(4) = 
     >      480*a(5)+480*a(6)-3360*a(7)-3360*a(8)+13440*a(9) 

         f(5) = 1344*a(6)+1344*a(7)-10752*a(8)-10752*a(9) 

         f(6) = 3584*a(7)+3584*a(8)-32256*a(9) 

         f(7) = 9216*a(8)+9216*a(9)
         f(8) = 23040*a(9) 

      case(10)
         f(0) = 2*a(1)+2*a(2)-6*a(3)-6*a(4)+12*a(5)+
     >      12*a(6)-20*a(7)-20*a(8)+30*a(9)+30*a(10) 

         f(1) = 12*a(2)+12*a(3)-48*a(4)-48*a(5)+120*a(6)+120*a(7)-
     >      240*a(8)-240*a(9)+420*a(10) 

         f(2) = 48*a(3)+48*a(4)-240*a(5)-240*a(6)+720*a(7)+
     >      720*a(8)-1680*a(9)-1680*a(10) 

         f(3) = 160*a(4)+160*a(5)-960*a(6)-960*a(7)+3360*a(8)+
     >      3360*a(9)-8960*a(10) 

         f(4) = 480*a(5)+480*a(6)-3360*a(7)-3360*a(8)+13440*a(9)+
     >      13440*a(10)
         f(5) = 1344*a(6)+1344*a(7)-10752*a(8)-
     >      10752*a(9)+48384*a(10) 

         f(6) = 3584*a(7)+3584*a(8)-32256*a(9)-32256*a(10) 

         f(7) = 9216*a(8)+9216*a(9)-92160*a(10) 

         f(8) = 23040*a(9)+23040*a(10)
         f(9) = 56320*a(10) 

      case(11)
         f(0) = 2*a(1)+2*a(2)-6*a(3)-6*a(4)+12*a(5)+
     >      12*a(6)-20*a(7)-20*a(8)+30*a(9)+30*a(10)-42*a(11) 

         f(1) = 12*a(2)+12*a(3)-48*a(4)-48*a(5)+120*a(6)+120*a(7)-
     >      240*a(8)-240*a(9)+420*a(10)+420*a(11) 

         f(2) = 48*a(3)+48*a(4)-240*a(5)-240*a(6)+720*a(7)+
     >      720*a(8)-1680*a(9)-1680*a(10)+3360*a(11) 

         f(3) = 160*a(4)+160*a(5)-960*a(6)-960*a(7)+3360*a(8)+
     >      3360*a(9)-8960*a(10)-8960*a(11) 

         f(4) = 480*a(5)+480*a(6)-3360*a(7)-3360*a(8)+13440*a(9)+
     >      13440*a(10)-40320*a(11) 

         f(5) = 1344*a(6)+1344*a(7)-10752*a(8)-10752*a(9)+
     >      48384*a(10)+48384*a(11) 

         f(6) = 3584*a(7)+3584*a(8)-32256*a(9)-32256*a(10)+
     >      161280*a(11)
         f(7) = 
     >      9216*a(8)+9216*a(9)-92160*a(10)-92160*a(11) 

         f(8) = 23040*a(9)+23040*a(10)-253440*a(11) 

         f(9) = 56320*a(10)+56320*a(11)
         f(10) = 135168*a(11) 

      case(12)
         f(0) = 2*a(1)+2*a(2)-6*a(3)-6*a(4)+12*a(5)+
     >      12*a(6)-20*a(7)-20*a(8)+30*a(9)+30*a(10)-42*a(11)-42*a(12)

         f(1) = 12*a(2)+12*a(3)-48*a(4)-48*a(5)+120*a(6)+120*a(7)-
     >      240*a(8)-240*a(9)+420*a(10)+420*a(11)-672*a(12) 

         f(2) = 48*a(3)+48*a(4)-240*a(5)-240*a(6)+720*a(7)+
     >      720*a(8)-1680*a(9)-1680*a(10)+3360*a(11)+3360*a(12) 

         f(3) = 160*a(4)+160*a(5)-960*a(6)-960*a(7)+3360*a(8)+
     >      3360*a(9)-8960*a(10)-8960*a(11)+20160*a(12) 

         f(4) = 480*a(5)+480*a(6)-3360*a(7)-3360*a(8)+13440*a(9)+
     >      13440*a(10)-40320*a(11)-40320*a(12) 

         f(5) = 1344*a(6)+1344*a(7)-10752*a(8)-10752*a(9)+
     >      48384*a(10)+48384*a(11)-161280*a(12) 

         f(6) = 3584*a(7)+3584*a(8)-32256*a(9)-32256*a(10)+
     >      161280*a(11)+161280*a(12) 

         f(7) = 9216*a(8)+9216*a(9)-92160*a(10)-92160*a(11)+
     >      506880*a(12)
         f(8) = 
     >      23040*a(9)+23040*a(10)-253440*a(11)-253440*a(12) 

         f(9) = 56320*a(10)+56320*a(11)-675840*a(12) 

         f(10) = 135168*a(11)+135168*a(12)
         f(11) = 319488*a(12) 

      case(13)
         f(0) = 2*a(1)+2*a(2)-6*a(3)-6*a(4)+12*a(5)+
     >      12*a(6)-20*a(7)-20*a(8)+30*a(9)+30*a(10)-42*a(11)-
     >      42*a(12)+56*a(13)
         f(1) = 
     >      12*a(2)+12*a(3)-48*a(4)-48*a(5)+120*a(6)+120*a(7)-
     >      240*a(8)-240*a(9)+420*a(10)+420*a(11)-672*a(12)-672*a(13) 

         f(2) = 48*a(3)+48*a(4)-240*a(5)-240*a(6)+720*a(7)+
     >      720*a(8)-1680*a(9)-1680*a(10)+3360*a(11)+3360*a(12)-
     >      6048*a(13)
         f(3) = 160*a(4)+160*a(5)-960*a(6)-960*a(7)+
     >      3360*a(8)+3360*a(9)-8960*a(10)-8960*a(11)+20160*a(12)+
     >      20160*a(13)
         f(4) = 480*a(5)+480*a(6)-3360*a(7)-3360*a(8)+
     >      13440*a(9)+13440*a(10)-40320*a(11)-40320*a(12)+100800*a(13) 

         f(5) = 1344*a(6)+1344*a(7)-10752*a(8)-10752*a(9)+
     >      48384*a(10)+48384*a(11)-161280*a(12)-161280*a(13) 

         f(6) = 3584*a(7)+3584*a(8)-32256*a(9)-32256*a(10)+
     >      161280*a(11)+161280*a(12)-591360*a(13) 

         f(7) = 9216*a(8)+9216*a(9)-92160*a(10)-92160*a(11)+
     >      506880*a(12)+506880*a(13) 

         f(8) = 23040*a(9)+23040*a(10)-253440*a(11)-253440*a(12)+
     >      1520640*a(13)
         f(9) = 
     >      56320*a(10)+56320*a(11)-675840*a(12)-675840*a(13) 

         f(10) = 135168*a(11)+135168*a(12)-1757184*a(13) 

         f(11) = 319488*a(12)+319488*a(13)
         f(12) = 745472*a(13) 

      case(14)
         f(0) = 2*a(1)+2*a(2)-6*a(3)-6*a(4)+12*a(5)+
     >      12*a(6)-20*a(7)-20*a(8)+30*a(9)+30*a(10)-42*a(11)-
     >      42*a(12)+56*a(13)+56*a(14) 

         f(1) = 12*a(2)+12*a(3)-48*a(4)-48*a(5)+120*a(6)+120*a(7)-
     >      240*a(8)-240*a(9)+420*a(10)+420*a(11)-672*a(12)-672*a(13)+
     >      1008*a(14)
         f(2) = 48*a(3)+48*a(4)-240*a(5)-240*a(6)+
     >      720*a(7)+720*a(8)-1680*a(9)-1680*a(10)+3360*a(11)+
     >      3360*a(12)-6048*a(13)-6048*a(14) 

         f(3) = 160*a(4)+160*a(5)-960*a(6)-960*a(7)+3360*a(8)+
     >      3360*a(9)-8960*a(10)-8960*a(11)+20160*a(12)+20160*a(13)-
     >      40320*a(14)
         f(4) = 480*a(5)+480*a(6)-3360*a(7)-3360*a(8)+
     >      13440*a(9)+13440*a(10)-40320*a(11)-40320*a(12)+100800*a(13)+
     >      100800*a(14)
         f(5) = 
     >      1344*a(6)+1344*a(7)-10752*a(8)-10752*a(9)+48384*a(10)+
     >      48384*a(11)-161280*a(12)-161280*a(13)+443520*a(14) 

         f(6) = 3584*a(7)+3584*a(8)-32256*a(9)-32256*a(10)+
     >      161280*a(11)+161280*a(12)-591360*a(13)-591360*a(14) 

         f(7) = 9216*a(8)+9216*a(9)-92160*a(10)-92160*a(11)+
     >      506880*a(12)+506880*a(13)-2027520*a(14) 

         f(8) = 23040*a(9)+23040*a(10)-253440*a(11)-253440*a(12)+
     >      1520640*a(13)+1520640*a(14) 

         f(9) = 56320*a(10)+56320*a(11)-675840*a(12)-675840*a(13)+
     >      4392960*a(14)
         f(10) = 
     >      135168*a(11)+135168*a(12)-1757184*a(13)-1757184*a(14) 

         f(11) = 319488*a(12)+319488*a(13)-4472832*a(14) 

         f(12) = 745472*a(13)+745472*a(14)
         f(13) = 1720320*a(14) 

      case(15)
         f(0) = 2*a(1)+2*a(2)-6*a(3)-6*a(4)+12*a(5)+
     >      12*a(6)-20*a(7)-20*a(8)+30*a(9)+30*a(10)-42*a(11)-
     >      42*a(12)+56*a(13)+56*a(14)-72*a(15) 

         f(1) = 12*a(2)+12*a(3)-48*a(4)-48*a(5)+120*a(6)+120*a(7)-
     >      240*a(8)-240*a(9)+420*a(10)+420*a(11)-672*a(12)-672*a(13)+
     >      1008*a(14)+1008*a(15) 

         f(2) = 48*a(3)+48*a(4)-240*a(5)-240*a(6)+720*a(7)+
     >      720*a(8)-1680*a(9)-1680*a(10)+3360*a(11)+3360*a(12)-
     >      6048*a(13)-6048*a(14)+10080*a(15) 

         f(3) = 160*a(4)+160*a(5)-960*a(6)-960*a(7)+3360*a(8)+
     >      3360*a(9)-8960*a(10)-8960*a(11)+20160*a(12)+20160*a(13)-
     >      40320*a(14)-40320*a(15) 

         f(4) = 480*a(5)+480*a(6)-3360*a(7)-3360*a(8)+13440*a(9)+
     >      13440*a(10)-40320*a(11)-40320*a(12)+100800*a(13)+
     >      100800*a(14)-221760*a(15) 

         f(5) = 1344*a(6)+1344*a(7)-10752*a(8)-10752*a(9)+
     >      48384*a(10)+48384*a(11)-161280*a(12)-161280*a(13)+
     >      443520*a(14)+443520*a(15) 

         f(6) = 3584*a(7)+3584*a(8)-32256*a(9)-32256*a(10)+
     >      161280*a(11)+161280*a(12)-591360*a(13)-591360*a(14)+
     >      1774080*a(15)
         f(7) = 
     >      9216*a(8)+9216*a(9)-92160*a(10)-92160*a(11)+506880*a(12)+
     >      506880*a(13)-2027520*a(14)-2027520*a(15) 

         f(8) = 23040*a(9)+23040*a(10)-253440*a(11)-253440*a(12)+
     >      1520640*a(13)+1520640*a(14)-6589440*a(15) 

         f(9) = 56320*a(10)+56320*a(11)-675840*a(12)-675840*a(13)+
     >      4392960*a(14)+4392960*a(15) 

         f(10) = 135168*a(11)+135168*a(12)-1757184*a(13)-1757184*a(14)+
     >      12300288*a(15)
         f(11) = 
     >      319488*a(12)+319488*a(13)-4472832*a(14)-4472832*a(15) 

         f(12) = 745472*a(13)+745472*a(14)-11182080*a(15) 

         f(13) = 1720320*a(14)+1720320*a(15)
         f(14) = 3932160*a(15)


      case default
         stop ' coef1: statement is missing for Nl>15 at l=1'
      end select
      
*     10 d states
      case(2)                   ! for d states
      select case(Nl)

      case(1)
         f(0) = 3*a(1) 

      case(2)
         f(0) = 3*a(1)+3*a(2)
         f(1) = 24*a(2) 

      case(3)
         f(0) = 3*a(1)+3*a(2)-12*a(3) 

         f(1) = 24*a(2)+24*a(3)
         f(2) = 120*a(3) 

      case(4)
         f(0) = 3*a(1)+3*a(2)-12*a(3)-12*a(4) 

         f(1) = 24*a(2)+24*a(3)-120*a(4)
         f(2) = 120*a(3)+120*a(4) 

         f(3) = 480*a(4)
      case(5) 

         f(0) = 3*a(1)+3*a(2)-12*a(3)-12*a(4)+30*a(5) 

         f(1) = 24*a(2)+24*a(3)-120*a(4)-120*a(5) 

         f(2) = 120*a(3)+120*a(4)-720*a(5) 

         f(3) = 480*a(4)+480*a(5)
         f(4) = 1680*a(5) 

      case(6)
         f(0) = 3*a(1)+3*a(2)-12*a(3)-12*a(4)+30*a(5)+
     >      30*a(6)
         f(1) = 24*a(2)+24*a(3)-120*a(4)-120*a(5)+
     >      360*a(6)
         f(2) = 120*a(3)+120*a(4)-720*a(5)-720*a(6) 

         f(3) = 480*a(4)+480*a(5)-3360*a(6) 

         f(4) = 1680*a(5)+1680*a(6)
         f(5) = 5376*a(6) 

      case(7)
         f(0) = 3*a(1)+3*a(2)-12*a(3)-12*a(4)+30*a(5)+
     >      30*a(6)-60*a(7)
         f(1) = 
     >      24*a(2)+24*a(3)-120*a(4)-120*a(5)+360*a(6)+360*a(7) 

         f(2) = 120*a(3)+120*a(4)-720*a(5)-720*a(6)+2520*a(7) 

         f(3) = 480*a(4)+480*a(5)-3360*a(6)-3360*a(7) 

         f(4) = 1680*a(5)+1680*a(6)-13440*a(7) 

         f(5) = 5376*a(6)+5376*a(7)
         f(6) = 16128*a(7) 

      case(8)
         f(0) = 3*a(1)+3*a(2)-12*a(3)-12*a(4)+30*a(5)+
     >      30*a(6)-60*a(7)-60*a(8) 

         f(1) = 24*a(2)+24*a(3)-120*a(4)-120*a(5)+360*a(6)+
     >      360*a(7)-840*a(8)
         f(2) = 
     >      120*a(3)+120*a(4)-720*a(5)-720*a(6)+2520*a(7)+2520*a(8) 

         f(3) = 480*a(4)+480*a(5)-3360*a(6)-3360*a(7)+13440*a(8) 

         f(4) = 1680*a(5)+1680*a(6)-13440*a(7)-13440*a(8) 

         f(5) = 5376*a(6)+5376*a(7)-48384*a(8) 

         f(6) = 16128*a(7)+16128*a(8)
         f(7) = 46080*a(8) 

      case(9)
         f(0) = 3*a(1)+3*a(2)-12*a(3)-12*a(4)+30*a(5)+
     >      30*a(6)-60*a(7)-60*a(8)+105*a(9) 

         f(1) = 24*a(2)+24*a(3)-120*a(4)-120*a(5)+360*a(6)+
     >      360*a(7)-840*a(8)-840*a(9) 

         f(2) = 120*a(3)+120*a(4)-720*a(5)-720*a(6)+2520*a(7)+
     >      2520*a(8)-6720*a(9)
         f(3) = 
     >      480*a(4)+480*a(5)-3360*a(6)-3360*a(7)+13440*a(8)+13440*a(9) 

         f(4) = 1680*a(5)+1680*a(6)-13440*a(7)-13440*a(8)+60480*a(9) 

         f(5) = 5376*a(6)+5376*a(7)-48384*a(8)-48384*a(9) 

         f(6) = 16128*a(7)+16128*a(8)-161280*a(9) 

         f(7) = 46080*a(8)+46080*a(9)
         f(8) = 126720*a(9) 

      case(10)
         f(0) = 3*a(1)+3*a(2)-12*a(3)-12*a(4)+30*a(5)+
     >      30*a(6)-60*a(7)-60*a(8)+105*a(9)+105*a(10) 

         f(1) = 24*a(2)+24*a(3)-120*a(4)-120*a(5)+360*a(6)+
     >      360*a(7)-840*a(8)-840*a(9)+1680*a(10) 

         f(2) = 120*a(3)+120*a(4)-720*a(5)-720*a(6)+2520*a(7)+
     >      2520*a(8)-6720*a(9)-6720*a(10) 

         f(3) = 480*a(4)+480*a(5)-3360*a(6)-3360*a(7)+13440*a(8)+
     >      13440*a(9)-40320*a(10) 

         f(4) = 1680*a(5)+1680*a(6)-13440*a(7)-13440*a(8)+60480*a(9)+
     >      60480*a(10)
         f(5) = 5376*a(6)+5376*a(7)-48384*a(8)-
     >      48384*a(9)+241920*a(10) 

         f(6) = 16128*a(7)+16128*a(8)-161280*a(9)-161280*a(10) 

         f(7) = 46080*a(8)+46080*a(9)-506880*a(10) 

         f(8) = 126720*a(9)+126720*a(10)
         f(9) = 337920*a(10)

      case default
         stop ' coef1: statement is missing for Nl>10 at l=2'
      end select
      
*     10 f states
      case(3)                   ! for f states
      select case(Nl)

      case(1)
         f(0) = 4*a(1) 

      case(2)
         f(0) = 4*a(1)+4*a(2)
         f(1) = 40*a(2) 

      case(3)
         f(0) = 4*a(1)+4*a(2)-20*a(3) 

         f(1) = 40*a(2)+40*a(3)
         f(2) = 240*a(3) 

      case(4)
         f(0) = 4*a(1)+4*a(2)-20*a(3)-20*a(4) 

         f(1) = 40*a(2)+40*a(3)-240*a(4)
         f(2) = 240*a(3)+240*a(4) 

         f(3) = 1120*a(4)
      case(5) 

         f(0) = 4*a(1)+4*a(2)-20*a(3)-20*a(4)+60*a(5) 

         f(1) = 40*a(2)+40*a(3)-240*a(4)-240*a(5) 

         f(2) = 240*a(3)+240*a(4)-1680*a(5) 

         f(3) = 1120*a(4)+1120*a(5)
         f(4) = 4480*a(5) 

      case(6)
         f(0) = 4*a(1)+4*a(2)-20*a(3)-20*a(4)+60*a(5)+
     >      60*a(6)
         f(1) = 40*a(2)+40*a(3)-240*a(4)-240*a(5)+
     >      840*a(6)
         f(2) = 240*a(3)+240*a(4)-1680*a(5)-1680*a(6) 

         f(3) = 1120*a(4)+1120*a(5)-8960*a(6) 

         f(4) = 4480*a(5)+4480*a(6)
         f(5) = 16128*a(6) 

      case(7)
         f(0) = 4*a(1)+4*a(2)-20*a(3)-20*a(4)+60*a(5)+
     >      60*a(6)-140*a(7)
         f(1) = 
     >      40*a(2)+40*a(3)-240*a(4)-240*a(5)+840*a(6)+840*a(7) 

         f(2) = 240*a(3)+240*a(4)-1680*a(5)-1680*a(6)+6720*a(7) 

         f(3) = 1120*a(4)+1120*a(5)-8960*a(6)-8960*a(7) 

         f(4) = 4480*a(5)+4480*a(6)-40320*a(7) 

         f(5) = 16128*a(6)+16128*a(7)
         f(6) = 53760*a(7) 

      case(8)
         f(0) = 4*a(1)+4*a(2)-20*a(3)-20*a(4)+60*a(5)+
     >      60*a(6)-140*a(7)-140*a(8) 

         f(1) = 40*a(2)+40*a(3)-240*a(4)-240*a(5)+840*a(6)+
     >      840*a(7)-2240*a(8)
         f(2) = 
     >      240*a(3)+240*a(4)-1680*a(5)-1680*a(6)+6720*a(7)+6720*a(8) 

         f(3) = 1120*a(4)+1120*a(5)-8960*a(6)-8960*a(7)+40320*a(8) 

         f(4) = 4480*a(5)+4480*a(6)-40320*a(7)-40320*a(8) 

         f(5) = 16128*a(6)+16128*a(7)-161280*a(8) 

         f(6) = 53760*a(7)+53760*a(8)
         f(7) = 168960*a(8) 

      case(9)
         f(0) = 4*a(1)+4*a(2)-20*a(3)-20*a(4)+60*a(5)+
     >      60*a(6)-140*a(7)-140*a(8)+280*a(9) 

         f(1) = 40*a(2)+40*a(3)-240*a(4)-240*a(5)+840*a(6)+
     >      840*a(7)-2240*a(8)-2240*a(9) 

         f(2) = 240*a(3)+240*a(4)-1680*a(5)-1680*a(6)+6720*a(7)+
     >      6720*a(8)-20160*a(9) 

         f(3) = 1120*a(4)+1120*a(5)-8960*a(6)-8960*a(7)+40320*a(8)+
     >      40320*a(9)
         f(4) = 4480*a(5)+4480*a(6)-40320*a(7)-
     >      40320*a(8)+201600*a(9) 

         f(5) = 16128*a(6)+16128*a(7)-161280*a(8)-161280*a(9) 

         f(6) = 53760*a(7)+53760*a(8)-591360*a(9) 

         f(7) = 168960*a(8)+168960*a(9)
         f(8) = 506880*a(9) 

      case(10)
         f(0) = 4*a(1)+4*a(2)-20*a(3)-20*a(4)+60*a(5)+
     >      60*a(6)-140*a(7)-140*a(8)+280*a(9)+280*a(10) 

         f(1) = 40*a(2)+40*a(3)-240*a(4)-240*a(5)+840*a(6)+
     >      840*a(7)-2240*a(8)-2240*a(9)+5040*a(10) 

         f(2) = 240*a(3)+240*a(4)-1680*a(5)-1680*a(6)+6720*a(7)+
     >      6720*a(8)-20160*a(9)-20160*a(10) 

         f(3) = 1120*a(4)+1120*a(5)-8960*a(6)-8960*a(7)+40320*a(8)+
     >      40320*a(9)-134400*a(10) 

         f(4) = 4480*a(5)+4480*a(6)-40320*a(7)-40320*a(8)+
     >      201600*a(9)+201600*a(10) 

         f(5) = 16128*a(6)+16128*a(7)-161280*a(8)-161280*a(9)+
     >      887040*a(10)
         f(6) = 
     >      53760*a(7)+53760*a(8)-591360*a(9)-591360*a(10) 

         f(7) = 168960*a(8)+168960*a(9)-2027520*a(10) 

         f(8) = 506880*a(9)+506880*a(10)
         f(9) = 1464320*a(10)
      case default
         stop ' coef1: statement is missing for Nl>10 at l=3'
      end select
    
      case default
         stop ' coef1: statement is missing for ll>3'
      end select
      return
      end
      
*------------------------------------------------------

      subroutine coef0(ll,Nl,a,f)
*     table of coefficients for sumk0 polynomial

      real*8 a(20),f(0:20)

      select case(ll)
*     20 s states
      case(0)                   ! for s states
      select case(Nl)

      case(1)
         f(0) = a(1)
      case(2) 

         f(0) = a(1)+a(2)
         f(1) = 2*a(2) 

      case(3)
         f(0) = a(1)+a(2)
         f(1) = 2*a(2)+2*a(3) 

         f(2) = 4*a(3)
      case(4) 

         f(0) = a(1)+a(2)
         f(1) = 2*a(2)+2*a(3)-2*a(4) 

         f(2) = 4*a(3)+4*a(4)
         f(3) = 8*a(4) 

      case(5)
         f(0) = a(1)+a(2)+a(5) 

         f(1) = 2*a(2)+2*a(3)-2*a(4)-2*a(5) 

         f(2) = 4*a(3)+4*a(4)-8*a(5)
         f(3) = 8*a(4)+8*a(5) 

         f(4) = 16*a(5)
      case(6) 

         f(0) = a(1)+a(2)+a(5)+a(6) 

         f(1) = 2*a(2)+2*a(3)-2*a(4)-2*a(5)+4*a(6) 

         f(2) = 4*a(3)+4*a(4)-8*a(5)-8*a(6) 

         f(3) = 8*a(4)+8*a(5)-24*a(6)
         f(4) = 16*a(5)+16*a(6) 

         f(5) = 32*a(6)
      case(7) 

         f(0) = a(1)+a(2)+a(5)+a(6) 

         f(1) = 2*a(2)+2*a(3)-2*a(4)-2*a(5)+4*a(6)+4*a(7) 

         f(2) = 4*a(3)+4*a(4)-8*a(5)-8*a(6)+16*a(7) 

         f(3) = 8*a(4)+8*a(5)-24*a(6)-24*a(7) 

         f(4) = 16*a(5)+16*a(6)-64*a(7)
         f(5) = 32*a(6)+32*a(7) 

         f(6) = 64*a(7)
      case(8) 

         f(0) = a(1)+a(2)+a(5)+a(6) 

         f(1) = 2*a(2)+2*a(3)-2*a(4)-2*a(5)+4*a(6)+4*a(7)-4*a(8) 

         f(2) = 4*a(3)+4*a(4)-8*a(5)-8*a(6)+16*a(7)+16*a(8) 

         f(3) = 8*a(4)+8*a(5)-24*a(6)-24*a(7)+56*a(8) 

         f(4) = 16*a(5)+16*a(6)-64*a(7)-64*a(8) 

         f(5) = 32*a(6)+32*a(7)-160*a(8)
         f(6) = 64*a(7)+64*a(8) 

         f(7) = 128*a(8)
      case(9) 

         f(0) = a(1)+a(2)+a(5)+a(6)+a(9) 

         f(1) = 2*a(2)+2*a(3)-2*a(4)-2*a(5)+4*a(6)+4*a(7)-
     >      4*a(8)-4*a(9)
         f(2) = 
     >      4*a(3)+4*a(4)-8*a(5)-8*a(6)+16*a(7)+16*a(8)-24*a(9) 

         f(3) = 8*a(4)+8*a(5)-24*a(6)-24*a(7)+56*a(8)+56*a(9) 

         f(4) = 16*a(5)+16*a(6)-64*a(7)-64*a(8)+176*a(9) 

         f(5) = 32*a(6)+32*a(7)-160*a(8)-160*a(9) 

         f(6) = 64*a(7)+64*a(8)-384*a(9)
         f(7) = 128*a(8)+128*a(9) 

         f(8) = 256*a(9)
      case(10) 

         f(0) = a(1)+a(2)+a(5)+a(6)+a(9)+a(10) 

         f(1) = 2*a(2)+2*a(3)-2*a(4)-2*a(5)+4*a(6)+4*a(7)-
     >      4*a(8)-4*a(9)+6*a(10) 

         f(2) = 4*a(3)+4*a(4)-8*a(5)-8*a(6)+16*a(7)+16*a(8)-
     >      24*a(9)-24*a(10)
         f(3) = 
     >      8*a(4)+8*a(5)-24*a(6)-24*a(7)+56*a(8)+56*a(9)-104*a(10) 

         f(4) = 16*a(5)+16*a(6)-64*a(7)-64*a(8)+176*a(9)+176*a(10) 

         f(5) = 32*a(6)+32*a(7)-160*a(8)-160*a(9)+512*a(10) 

         f(6) = 64*a(7)+64*a(8)-384*a(9)-384*a(10) 

         f(7) = 128*a(8)+128*a(9)-896*a(10) 

         f(8) = 256*a(9)+256*a(10)
         f(9) = 512*a(10) 

      case(11)
         f(0) = a(1)+a(2)+a(5)+a(6)+a(9)+a(10) 

         f(1) = 2*a(2)+2*a(3)-2*a(4)-2*a(5)+4*a(6)+4*a(7)-
     >      4*a(8)-4*a(9)+6*a(10)+6*a(11) 

         f(2) = 4*a(3)+4*a(4)-8*a(5)-8*a(6)+16*a(7)+16*a(8)-
     >      24*a(9)-24*a(10)+36*a(11) 

         f(3) = 8*a(4)+8*a(5)-24*a(6)-24*a(7)+56*a(8)+56*a(9)-
     >      104*a(10)-104*a(11)
         f(4) = 
     >      16*a(5)+16*a(6)-64*a(7)-64*a(8)+176*a(9)+176*a(10)-
     >      384*a(11)
         f(5) = 32*a(6)+32*a(7)-160*a(8)-160*a(9)+
     >      512*a(10)+512*a(11)
         f(6) = 
     >      64*a(7)+64*a(8)-384*a(9)-384*a(10)+1408*a(11) 

         f(7) = 128*a(8)+128*a(9)-896*a(10)-896*a(11) 

         f(8) = 256*a(9)+256*a(10)-2048*a(11) 

         f(9) = 512*a(10)+512*a(11)
         f(10) = 1024*a(11) 

      case(12)
         f(0) = a(1)+a(2)+a(5)+a(6)+a(9)+a(10) 

         f(1) = 2*a(2)+2*a(3)-2*a(4)-2*a(5)+4*a(6)+4*a(7)-
     >      4*a(8)-4*a(9)+6*a(10)+6*a(11)-6*a(12) 

         f(2) = 4*a(3)+4*a(4)-8*a(5)-8*a(6)+16*a(7)+16*a(8)-
     >      24*a(9)-24*a(10)+36*a(11)+36*a(12) 

         f(3) = 8*a(4)+8*a(5)-24*a(6)-24*a(7)+56*a(8)+56*a(9)-
     >      104*a(10)-104*a(11)+176*a(12) 

         f(4) = 16*a(5)+16*a(6)-64*a(7)-64*a(8)+176*a(9)+
     >      176*a(10)-384*a(11)-384*a(12) 

         f(5) = 32*a(6)+32*a(7)-160*a(8)-160*a(9)+512*a(10)+
     >      512*a(11)-1280*a(12) 

         f(6) = 64*a(7)+64*a(8)-384*a(9)-384*a(10)+1408*a(11)+
     >      1408*a(12)
         f(7) = 128*a(8)+128*a(9)-896*a(10)-896*a(11)+
     >      3712*a(12)
         f(8) = 256*a(9)+256*a(10)-2048*a(11)-
     >      2048*a(12)
         f(9) = 512*a(10)+512*a(11)-4608*a(12) 

         f(10) = 1024*a(11)+1024*a(12)
         f(11) = 2048*a(12) 

      case(13)
         f(0) = a(1)+a(2)+a(5)+a(6)+a(9)+a(10)+a(13) 

         f(1) = 2*a(2)+2*a(3)-2*a(4)-2*a(5)+4*a(6)+4*a(7)-
     >      4*a(8)-4*a(9)+6*a(10)+6*a(11)-6*a(12)-6*a(13) 

         f(2) = 4*a(3)+4*a(4)-8*a(5)-8*a(6)+16*a(7)+16*a(8)-
     >      24*a(9)-24*a(10)+36*a(11)+36*a(12)-48*a(13) 

         f(3) = 8*a(4)+8*a(5)-24*a(6)-24*a(7)+56*a(8)+56*a(9)-
     >      104*a(10)-104*a(11)+176*a(12)+176*a(13) 

         f(4) = 16*a(5)+16*a(6)-64*a(7)-64*a(8)+176*a(9)+
     >      176*a(10)-384*a(11)-384*a(12)+736*a(13) 

         f(5) = 32*a(6)+32*a(7)-160*a(8)-160*a(9)+512*a(10)+
     >      512*a(11)-1280*a(12)-1280*a(13) 

         f(6) = 64*a(7)+64*a(8)-384*a(9)-384*a(10)+1408*a(11)+
     >      1408*a(12)-3968*a(13) 

         f(7) = 128*a(8)+128*a(9)-896*a(10)-896*a(11)+3712*a(12)+
     >      3712*a(13)
         f(8) = 256*a(9)+256*a(10)-2048*a(11)-
     >      2048*a(12)+9472*a(13) 

         f(9) = 512*a(10)+512*a(11)-4608*a(12)-4608*a(13) 

         f(10) = 1024*a(11)+1024*a(12)-10240*a(13) 

         f(11) = 2048*a(12)+2048*a(13)
         f(12) = 4096*a(13) 

      case(14)
         f(0) = a(1)+a(2)+a(5)+a(6)+a(9)+a(10)+a(13)+a(14)
         f(1) = 2*a(2)+2*a(3)-2*a(4)-2*a(5)+4*a(6)+
     >      4*a(7)-4*a(8)-4*a(9)+6*a(10)+6*a(11)-6*a(12)-6*a(13)+
     >      8*a(14)
         f(2) = 4*a(3)+4*a(4)-8*a(5)-8*a(6)+16*a(7)+
     >      16*a(8)-24*a(9)-24*a(10)+36*a(11)+36*a(12)-48*a(13)-
     >      48*a(14)
         f(3) = 8*a(4)+8*a(5)-24*a(6)-24*a(7)+56*a(8)+
     >      56*a(9)-104*a(10)-104*a(11)+176*a(12)+176*a(13)-272*a(14) 

         f(4) = 16*a(5)+16*a(6)-64*a(7)-64*a(8)+176*a(9)+
     >      176*a(10)-384*a(11)-384*a(12)+736*a(13)+736*a(14) 

         f(5) = 32*a(6)+32*a(7)-160*a(8)-160*a(9)+512*a(10)+
     >      512*a(11)-1280*a(12)-1280*a(13)+2752*a(14) 

         f(6) = 64*a(7)+64*a(8)-384*a(9)-384*a(10)+1408*a(11)+
     >      1408*a(12)-3968*a(13)-3968*a(14) 

         f(7) = 128*a(8)+128*a(9)-896*a(10)-896*a(11)+3712*a(12)+
     >      3712*a(13)-11648*a(14) 

         f(8) = 256*a(9)+256*a(10)-2048*a(11)-2048*a(12)+9472*a(13)+
     >      9472*a(14)
         f(9) = 512*a(10)+512*a(11)-4608*a(12)-
     >      4608*a(13)+23552*a(14) 

         f(10) = 1024*a(11)+1024*a(12)-10240*a(13)-10240*a(14) 

         f(11) = 2048*a(12)+2048*a(13)-22528*a(14) 

         f(12) = 4096*a(13)+4096*a(14)
         f(13) = 8192*a(14) 

      case(15)
         f(0) = a(1)+a(2)+a(5)+a(6)+a(9)+a(10)+a(13)+a(14)
         f(1) = 2*a(2)+2*a(3)-2*a(4)-2*a(5)+4*a(6)+
     >      4*a(7)-4*a(8)-4*a(9)+6*a(10)+6*a(11)-6*a(12)-6*a(13)+
     >      8*a(14)+8*a(15)
         f(2) = 
     >      4*a(3)+4*a(4)-8*a(5)-8*a(6)+16*a(7)+16*a(8)-24*a(9)-
     >      24*a(10)+36*a(11)+36*a(12)-48*a(13)-48*a(14)+64*a(15) 

         f(3) = 8*a(4)+8*a(5)-24*a(6)-24*a(7)+56*a(8)+56*a(9)-
     >      104*a(10)-104*a(11)+176*a(12)+176*a(13)-272*a(14)-272*a(15)

         f(4) = 16*a(5)+16*a(6)-64*a(7)-64*a(8)+176*a(9)+176*a(10)-
     >      384*a(11)-384*a(12)+736*a(13)+736*a(14)-1280*a(15) 

         f(5) = 32*a(6)+32*a(7)-160*a(8)-160*a(9)+512*a(10)+
     >      512*a(11)-1280*a(12)-1280*a(13)+2752*a(14)+2752*a(15) 

         f(6) = 64*a(7)+64*a(8)-384*a(9)-384*a(10)+1408*a(11)+
     >      1408*a(12)-3968*a(13)-3968*a(14)+9472*a(15) 

         f(7) = 128*a(8)+128*a(9)-896*a(10)-896*a(11)+3712*a(12)+
     >      3712*a(13)-11648*a(14)-11648*a(15) 

         f(8) = 256*a(9)+256*a(10)-2048*a(11)-2048*a(12)+9472*a(13)+
     >      9472*a(14)-32768*a(15) 

         f(9) = 512*a(10)+512*a(11)-4608*a(12)-4608*a(13)+
     >      23552*a(14)+23552*a(15) 

         f(10) = 1024*a(11)+1024*a(12)-10240*a(13)-10240*a(14)+
     >      57344*a(15)
         f(11) = 
     >      2048*a(12)+2048*a(13)-22528*a(14)-22528*a(15) 

         f(12) = 4096*a(13)+4096*a(14)-49152*a(15) 

         f(13) = 8192*a(14)+8192*a(15)
         f(14) = 16384*a(15) 

      case(16)
         f(0) = a(1)+a(2)+a(5)+a(6)+a(9)+a(10)+a(13)+a(14)
         f(1) = 2*a(2)+2*a(3)-2*a(4)-2*a(5)+4*a(6)+
     >      4*a(7)-4*a(8)-4*a(9)+6*a(10)+6*a(11)-6*a(12)-6*a(13)+
     >      8*a(14)+8*a(15)-8*a(16) 

         f(2) = 4*a(3)+4*a(4)-8*a(5)-8*a(6)+16*a(7)+16*a(8)-
     >      24*a(9)-24*a(10)+36*a(11)+36*a(12)-48*a(13)-48*a(14)+
     >      64*a(15)+64*a(16)
         f(3) = 
     >      8*a(4)+8*a(5)-24*a(6)-24*a(7)+56*a(8)+56*a(9)-104*a(10)-
     >      104*a(11)+176*a(12)+176*a(13)-272*a(14)-272*a(15)+400*a(16)

         f(4) = 16*a(5)+16*a(6)-64*a(7)-64*a(8)+176*a(9)+176*a(10)-
     >      384*a(11)-384*a(12)+736*a(13)+736*a(14)-1280*a(15)-
     >      1280*a(16)
         f(5) = 32*a(6)+32*a(7)-160*a(8)-160*a(9)+
     >      512*a(10)+512*a(11)-1280*a(12)-1280*a(13)+2752*a(14)+
     >      2752*a(15)-5312*a(16) 

         f(6) = 64*a(7)+64*a(8)-384*a(9)-384*a(10)+1408*a(11)+
     >      1408*a(12)-3968*a(13)-3968*a(14)+9472*a(15)+9472*a(16) 

         f(7) = 128*a(8)+128*a(9)-896*a(10)-896*a(11)+3712*a(12)+
     >      3712*a(13)-11648*a(14)-11648*a(15)+30592*a(16) 

         f(8) = 256*a(9)+256*a(10)-2048*a(11)-2048*a(12)+9472*a(13)+
     >      9472*a(14)-32768*a(15)-32768*a(16) 

         f(9) = 512*a(10)+512*a(11)-4608*a(12)-4608*a(13)+
     >      23552*a(14)+23552*a(15)-89088*a(16) 

         f(10) = 1024*a(11)+1024*a(12)-10240*a(13)-10240*a(14)+
     >      57344*a(15)+57344*a(16) 

         f(11) = 2048*a(12)+2048*a(13)-22528*a(14)-22528*a(15)+
     >      137216*a(16)
         f(12) = 
     >      4096*a(13)+4096*a(14)-49152*a(15)-49152*a(16) 

         f(13) = 8192*a(14)+8192*a(15)-106496*a(16) 

         f(14) = 16384*a(15)+16384*a(16)
         f(15) = 32768*a(16) 

      case(17)
         f(0) = a(1)+a(2)+a(5)+a(6)+a(9)+a(10)+a(13)+a(14)+a(17)
         f(1) = 
     >      2*a(2)+2*a(3)-2*a(4)-2*a(5)+4*a(6)+4*a(7)-4*a(8)-
     >      4*a(9)+6*a(10)+6*a(11)-6*a(12)-6*a(13)+8*a(14)+8*a(15)-
     >      8*a(16)-8*a(17)
         f(2) = 
     >      4*a(3)+4*a(4)-8*a(5)-8*a(6)+16*a(7)+16*a(8)-24*a(9)-
     >      24*a(10)+36*a(11)+36*a(12)-48*a(13)-48*a(14)+64*a(15)+
     >      64*a(16)-80*a(17)
         f(3) = 
     >      8*a(4)+8*a(5)-24*a(6)-24*a(7)+56*a(8)+56*a(9)-104*a(10)-
     >      104*a(11)+176*a(12)+176*a(13)-272*a(14)-272*a(15)+
     >      400*a(16)+400*a(17)
         f(4) = 
     >      16*a(5)+16*a(6)-64*a(7)-64*a(8)+176*a(9)+176*a(10)-
     >      384*a(11)-384*a(12)+736*a(13)+736*a(14)-1280*a(15)-
     >      1280*a(16)+2080*a(17) 

         f(5) = 32*a(6)+32*a(7)-160*a(8)-160*a(9)+512*a(10)+
     >      512*a(11)-1280*a(12)-1280*a(13)+2752*a(14)+2752*a(15)-
     >      5312*a(16)-5312*a(17) 

         f(6) = 64*a(7)+64*a(8)-384*a(9)-384*a(10)+1408*a(11)+
     >      1408*a(12)-3968*a(13)-3968*a(14)+9472*a(15)+9472*a(16)-
     >      20096*a(17)
         f(7) = 128*a(8)+128*a(9)-896*a(10)-896*a(11)+
     >      3712*a(12)+3712*a(13)-11648*a(14)-11648*a(15)+30592*a(16)+
     >      30592*a(17)
         f(8) = 256*a(9)+256*a(10)-2048*a(11)-
     >      2048*a(12)+9472*a(13)+9472*a(14)-32768*a(15)-32768*a(16)+
     >      93952*a(17)
         f(9) = 512*a(10)+512*a(11)-4608*a(12)-
     >      4608*a(13)+23552*a(14)+23552*a(15)-89088*a(16)-89088*a(17) 

         f(10) = 1024*a(11)+1024*a(12)-10240*a(13)-10240*a(14)+
     >      57344*a(15)+57344*a(16)-235520*a(17) 

         f(11) = 2048*a(12)+2048*a(13)-22528*a(14)-22528*a(15)+
     >      137216*a(16)+137216*a(17) 

         f(12) = 4096*a(13)+4096*a(14)-49152*a(15)-49152*a(16)+
     >      323584*a(17)
         f(13) = 
     >      8192*a(14)+8192*a(15)-106496*a(16)-106496*a(17) 

         f(14) = 16384*a(15)+16384*a(16)-229376*a(17) 

         f(15) = 32768*a(16)+32768*a(17)
         f(16) = 65536*a(17) 

      case(18)
         f(0) = a(1)+a(2)+a(5)+a(6)+a(9)+a(10)+a(13)+a(14)+a(17)+a(18)
         f(1) = 
     >      2*a(2)+2*a(3)-2*a(4)-2*a(5)+4*a(6)+4*a(7)-4*a(8)-
     >      4*a(9)+6*a(10)+6*a(11)-6*a(12)-6*a(13)+8*a(14)+8*a(15)-
     >      8*a(16)-8*a(17)+10*a(18) 

         f(2) = 4*a(3)+4*a(4)-8*a(5)-8*a(6)+16*a(7)+16*a(8)-
     >      24*a(9)-24*a(10)+36*a(11)+36*a(12)-48*a(13)-48*a(14)+
     >      64*a(15)+64*a(16)-80*a(17)-80*a(18) 

         f(3) = 8*a(4)+8*a(5)-24*a(6)-24*a(7)+56*a(8)+56*a(9)-
     >      104*a(10)-104*a(11)+176*a(12)+176*a(13)-272*a(14)-
     >      272*a(15)+400*a(16)+400*a(17)-560*a(18) 

         f(4) = 16*a(5)+16*a(6)-64*a(7)-64*a(8)+176*a(9)+
     >      176*a(10)-384*a(11)-384*a(12)+736*a(13)+736*a(14)-
     >      1280*a(15)-1280*a(16)+2080*a(17)+2080*a(18) 

         f(5) = 32*a(6)+32*a(7)-160*a(8)-160*a(9)+512*a(10)+
     >      512*a(11)-1280*a(12)-1280*a(13)+2752*a(14)+2752*a(15)-
     >      5312*a(16)-5312*a(17)+9472*a(18) 

         f(6) = 64*a(7)+64*a(8)-384*a(9)-384*a(10)+1408*a(11)+
     >      1408*a(12)-3968*a(13)-3968*a(14)+9472*a(15)+9472*a(16)-
     >      20096*a(17)-20096*a(18) 

         f(7) = 128*a(8)+128*a(9)-896*a(10)-896*a(11)+3712*a(12)+
     >      3712*a(13)-11648*a(14)-11648*a(15)+30592*a(16)+30592*a(17)-
     >      70784*a(18)
         f(8) = 256*a(9)+256*a(10)-2048*a(11)-
     >      2048*a(12)+9472*a(13)+9472*a(14)-32768*a(15)-32768*a(16)+
     >      93952*a(17)+93952*a(18) 

         f(9) = 512*a(10)+512*a(11)-4608*a(12)-4608*a(13)+
     >      23552*a(14)+23552*a(15)-89088*a(16)-89088*a(17)+276992*a(18) 

         f(10) = 1024*a(11)+1024*a(12)-10240*a(13)-10240*a(14)+
     >      57344*a(15)+57344*a(16)-235520*a(17)-235520*a(18) 

         f(11) = 2048*a(12)+2048*a(13)-22528*a(14)-22528*a(15)+
     >      137216*a(16)+137216*a(17)-608256*a(18) 

         f(12) = 4096*a(13)+4096*a(14)-49152*a(15)-49152*a(16)+
     >      323584*a(17)+323584*a(18) 

         f(13) = 8192*a(14)+8192*a(15)-106496*a(16)-106496*a(17)+
     >      753664*a(18)
         f(14) = 
     >      16384*a(15)+16384*a(16)-229376*a(17)-229376*a(18) 

         f(15) = 32768*a(16)+32768*a(17)-491520*a(18) 

         f(16) = 65536*a(17)+65536*a(18)
         f(17) = 131072*a(18) 

      case(19)
         f(0) = a(1)+a(2)+a(5)+a(6)+a(9)+a(10)+a(13)+a(14)+a(17)+a(18)
         f(1) = 
     >      2*a(2)+2*a(3)-2*a(4)-2*a(5)+4*a(6)+4*a(7)-4*a(8)-
     >      4*a(9)+6*a(10)+6*a(11)-6*a(12)-6*a(13)+8*a(14)+8*a(15)-
     >      8*a(16)-8*a(17)+10*a(18)+10*a(19) 

         f(2) = 4*a(3)+4*a(4)-8*a(5)-8*a(6)+16*a(7)+16*a(8)-
     >      24*a(9)-24*a(10)+36*a(11)+36*a(12)-48*a(13)-48*a(14)+
     >      64*a(15)+64*a(16)-80*a(17)-80*a(18)+100*a(19) 

         f(3) = 8*a(4)+8*a(5)-24*a(6)-24*a(7)+56*a(8)+56*a(9)-
     >      104*a(10)-104*a(11)+176*a(12)+176*a(13)-272*a(14)-
     >      272*a(15)+400*a(16)+400*a(17)-560*a(18)-560*a(19) 

         f(4) = 16*a(5)+16*a(6)-64*a(7)-64*a(8)+176*a(9)+
     >      176*a(10)-384*a(11)-384*a(12)+736*a(13)+736*a(14)-
     >      1280*a(15)-1280*a(16)+2080*a(17)+2080*a(18)-3200*a(19) 

         f(5) = 32*a(6)+32*a(7)-160*a(8)-160*a(9)+512*a(10)+
     >      512*a(11)-1280*a(12)-1280*a(13)+2752*a(14)+2752*a(15)-
     >      5312*a(16)-5312*a(17)+9472*a(18)+9472*a(19) 

         f(6) = 64*a(7)+64*a(8)-384*a(9)-384*a(10)+1408*a(11)+
     >      1408*a(12)-3968*a(13)-3968*a(14)+9472*a(15)+9472*a(16)-
     >      20096*a(17)-20096*a(18)+39040*a(19) 

         f(7) = 128*a(8)+128*a(9)-896*a(10)-896*a(11)+3712*a(12)+
     >      3712*a(13)-11648*a(14)-11648*a(15)+30592*a(16)+30592*a(17)-
     >      70784*a(18)-70784*a(19) 

         f(8) = 256*a(9)+256*a(10)-2048*a(11)-2048*a(12)+9472*a(13)+
     >      9472*a(14)-32768*a(15)-32768*a(16)+93952*a(17)+93952*a(18)-
     >      235520*a(19)
         f(9) = 
     >      512*a(10)+512*a(11)-4608*a(12)-4608*a(13)+23552*a(14)+
     >      23552*a(15)-89088*a(16)-89088*a(17)+276992*a(18)
     >      +276992*a(19)

         f(10) = 1024*a(11)+1024*a(12)-10240*a(13)-10240*a(14)+
     >      57344*a(15)+57344*a(16)-235520*a(17)-235520*a(18)
     >      +789504*a(19)

         f(11) = 2048*a(12)+2048*a(13)-22528*a(14)-22528*a(15)+
     >      137216*a(16)+137216*a(17)-608256*a(18)-608256*a(19) 

         f(12) = 4096*a(13)+4096*a(14)-49152*a(15)-49152*a(16)+
     >      323584*a(17)+323584*a(18)-1540096*a(19) 

         f(13) = 8192*a(14)+8192*a(15)-106496*a(16)-106496*a(17)+
     >      753664*a(18)+753664*a(19) 

         f(14) = 16384*a(15)+16384*a(16)-229376*a(17)-229376*a(18)+
     >      1736704*a(19)
         f(15) = 
     >      32768*a(16)+32768*a(17)-491520*a(18)-491520*a(19) 

         f(16) = 65536*a(17)+65536*a(18)-1048576*a(19) 

         f(17) = 131072*a(18)+131072*a(19)
         f(18) = 262144*a(19) 

      case(20)
         f(0) = a(1)+a(2)+a(5)+a(6)+a(9)+a(10)+a(13)+a(14)+a(17)+a(18)
         f(1) = 
     >      2*a(2)+2*a(3)-2*a(4)-2*a(5)+4*a(6)+4*a(7)-4*a(8)-4*a(9)+
     >      6*a(10)+6*a(11)-6*a(12)-6*a(13)+8*a(14)+8*a(15)-8*a(16)-
     >      8*a(17)+10*a(18)+10*a(19)-10*a(20) 

         f(2) = 4*a(3)+4*a(4)-8*a(5)-8*a(6)+16*a(7)+16*a(8)-
     >      24*a(9)-24*a(10)+36*a(11)+36*a(12)-48*a(13)-48*a(14)+
     >      64*a(15)+64*a(16)-80*a(17)-80*a(18)+100*a(19)+100*a(20) 

         f(3) = 8*a(4)+8*a(5)-24*a(6)-24*a(7)+56*a(8)+56*a(9)-
     >      104*a(10)-104*a(11)+176*a(12)+176*a(13)-272*a(14)-
     >      272*a(15)+400*a(16)+400*a(17)-560*a(18)-560*a(19)+760*a(20) 

         f(4) = 16*a(5)+16*a(6)-64*a(7)-64*a(8)+176*a(9)+176*a(10)-
     >      384*a(11)-384*a(12)+736*a(13)+736*a(14)-1280*a(15)-
     >      1280*a(16)+2080*a(17)+2080*a(18)-3200*a(19)-3200*a(20) 

         f(5) = 32*a(6)+32*a(7)-160*a(8)-160*a(9)+512*a(10)+
     >      512*a(11)-1280*a(12)-1280*a(13)+2752*a(14)+2752*a(15)-
     >      5312*a(16)-5312*a(17)+9472*a(18)+9472*a(19)-15872*a(20) 

         f(6) = 64*a(7)+64*a(8)-384*a(9)-384*a(10)+1408*a(11)+
     >      1408*a(12)-3968*a(13)-3968*a(14)+9472*a(15)+9472*a(16)-
     >      20096*a(17)-20096*a(18)+39040*a(19)+39040*a(20) 

         f(7) = 128*a(8)+128*a(9)-896*a(10)-896*a(11)+3712*a(12)+
     >      3712*a(13)-11648*a(14)-11648*a(15)+30592*a(16)+30592*a(17)-
     >      70784*a(18)-70784*a(19)+148864*a(20) 

         f(8) = 256*a(9)+256*a(10)-2048*a(11)-2048*a(12)+9472*a(13)+
     >      9472*a(14)-32768*a(15)-32768*a(16)+93952*a(17)+93952*a(18)-
     >      235520*a(19)-235520*a(20) 

         f(9) = 512*a(10)+512*a(11)-4608*a(12)-4608*a(13)+
     >      23552*a(14)+23552*a(15)-89088*a(16)-89088*a(17)
     >      +276992*a(18)+
     >      276992*a(19)-748032*a(20) 

         f(10) = 1024*a(11)+1024*a(12)-10240*a(13)-10240*a(14)+
     >      57344*a(15)+57344*a(16)-235520*a(17)-235520*a(18)+
     >      789504*a(19)+789504*a(20) 

         f(11) = 2048*a(12)+2048*a(13)-22528*a(14)-22528*a(15)+
     >      137216*a(16)+137216*a(17)-608256*a(18)-608256*a(19)+
     >      2187264*a(20)
         f(12) = 
     >      4096*a(13)+4096*a(14)-49152*a(15)-49152*a(16)+323584*a(17)+
     >      323584*a(18)-1540096*a(19)-1540096*a(20) 

         f(13) = 8192*a(14)+8192*a(15)-106496*a(16)-106496*a(17)+
     >      753664*a(18)+753664*a(19)-3833856*a(20) 

         f(14) = 16384*a(15)+16384*a(16)-229376*a(17)-229376*a(18)+
     >      1736704*a(19)+1736704*a(20) 

         f(15) = 32768*a(16)+32768*a(17)-491520*a(18)-491520*a(19)+
     >      3964928*a(20)
         f(16) = 
     >      65536*a(17)+65536*a(18)-1048576*a(19)-1048576*a(20) 

         f(17) = 131072*a(18)+131072*a(19)-2228224*a(20) 

         f(18) = 262144*a(19)+262144*a(20)
         f(19) = 524288*a(20)

      case default
         stop ' coef0: statement is missing for Nl>20 at l=0'
      end select
      
*     15 p states
      case(1)                   ! for p states
      select case(Nl)

      case(1)
         f(0) = a(1)
      case(2) 

         f(0) = a(1)+a(2)
         f(1) = 4*a(2) 

      case(3)
         f(0) = a(1)+a(2)-a(3)
         f(1) = 4*a(2)+4*a(3) 

         f(2) = 12*a(3)
      case(4) 

         f(0) = a(1)+a(2)-a(3)-a(4) 

         f(1) = 4*a(2)+4*a(3)-8*a(4)
         f(2) = 12*a(3)+12*a(4) 

         f(3) = 32*a(4)
      case(5) 

         f(0) = a(1)+a(2)-a(3)-a(4)+2*a(5) 

         f(1) = 4*a(2)+4*a(3)-8*a(4)-8*a(5) 

         f(2) = 12*a(3)+12*a(4)-36*a(5)
         f(3) = 32*a(4)+32*a(5) 

         f(4) = 80*a(5)
      case(6) 

         f(0) = a(1)+a(2)-a(3)-a(4)+2*a(5)+2*a(6) 

         f(1) = 4*a(2)+4*a(3)-8*a(4)-8*a(5)+16*a(6) 

         f(2) = 12*a(3)+12*a(4)-36*a(5)-36*a(6) 

         f(3) = 32*a(4)+32*a(5)-128*a(6)
         f(4) = 80*a(5)+80*a(6) 

         f(5) = 192*a(6)
      case(7) 

         f(0) = a(1)+a(2)-a(3)-a(4)+2*a(5)+2*a(6)-2*a(7) 

         f(1) = 4*a(2)+4*a(3)-8*a(4)-8*a(5)+16*a(6)+16*a(7) 

         f(2) = 12*a(3)+12*a(4)-36*a(5)-36*a(6)+84*a(7) 

         f(3) = 32*a(4)+32*a(5)-128*a(6)-128*a(7) 

         f(4) = 80*a(5)+80*a(6)-400*a(7)
         f(5) = 192*a(6)+192*a(7) 

         f(6) = 448*a(7)
      case(8) 

         f(0) = a(1)+a(2)-a(3)-a(4)+2*a(5)+2*a(6)-2*a(7)-
     >      2*a(8)
         f(1) = 4*a(2)+4*a(3)-8*a(4)-8*a(5)+16*a(6)+
     >      16*a(7)-24*a(8)
         
         f(2) =
     >      12*a(3)+12*a(4)-36*a(5)-36*a(6)+84*a(7)+84*a(8)

         f(3) = 32*a(4)+32*a(5)-128*a(6)-128*a(7)+352*a(8) 

         f(4) = 80*a(5)+80*a(6)-400*a(7)-400*a(8) 

         f(5) = 192*a(6)+192*a(7)-1152*a(8) 

         f(6) = 448*a(7)+448*a(8)
         f(7) = 1024*a(8) 

      case(9)
         f(0) = a(1)+a(2)-a(3)-a(4)+2*a(5)+2*a(6)-
     >      2*a(7)-2*a(8)+3*a(9) 

         f(1) = 4*a(2)+4*a(3)-8*a(4)-8*a(5)+16*a(6)+16*a(7)-
     >      24*a(8)-24*a(9)
         f(2) = 
     >      12*a(3)+12*a(4)-36*a(5)-36*a(6)+84*a(7)+84*a(8)-156*a(9) 

         f(3) = 32*a(4)+32*a(5)-128*a(6)-128*a(7)+352*a(8)+
     >      352*a(9)
         f(4) = 80*a(5)+80*a(6)-400*a(7)-400*a(8)+
     >      1280*a(9)
         f(5) = 192*a(6)+192*a(7)-1152*a(8)-1152*a(9) 

         f(6) = 448*a(7)+448*a(8)-3136*a(9) 

         f(7) = 1024*a(8)+1024*a(9)
         f(8) = 2304*a(9) 

      case(10)
         f(0) = a(1)+a(2)-a(3)-a(4)+2*a(5)+2*a(6)-
     >      2*a(7)-2*a(8)+3*a(9)+3*a(10) 

         f(1) = 4*a(2)+4*a(3)-8*a(4)-8*a(5)+16*a(6)+16*a(7)-
     >      24*a(8)-24*a(9)+36*a(10) 

         f(2) = 12*a(3)+12*a(4)-36*a(5)-36*a(6)+84*a(7)+84*a(8)-
     >      156*a(9)-156*a(10)
         f(3) = 
     >      32*a(4)+32*a(5)-128*a(6)-128*a(7)+352*a(8)+352*a(9)-
     >      768*a(10)
         f(4) = 80*a(5)+80*a(6)-400*a(7)-400*a(8)+
     >      1280*a(9)+1280*a(10) 

         f(5) = 192*a(6)+192*a(7)-1152*a(8)-1152*a(9)+4224*a(10) 

         f(6) = 448*a(7)+448*a(8)-3136*a(9)-3136*a(10) 

         f(7) = 1024*a(8)+1024*a(9)-8192*a(10) 

         f(8) = 2304*a(9)+2304*a(10)
         f(9) = 5120*a(10) 

      case(11)
         f(0) = a(1)+a(2)-a(3)-a(4)+2*a(5)+2*a(6)-
     >      2*a(7)-2*a(8)+3*a(9)+3*a(10)-3*a(11) 

         f(1) = 4*a(2)+4*a(3)-8*a(4)-8*a(5)+16*a(6)+16*a(7)-
     >      24*a(8)-24*a(9)+36*a(10)+36*a(11) 

         f(2) = 12*a(3)+12*a(4)-36*a(5)-36*a(6)+84*a(7)+84*a(8)-
     >      156*a(9)-156*a(10)+264*a(11) 

         f(3) = 32*a(4)+32*a(5)-128*a(6)-128*a(7)+352*a(8)+
     >      352*a(9)-768*a(10)-768*a(11) 

         f(4) = 80*a(5)+80*a(6)-400*a(7)-400*a(8)+1280*a(9)+
     >      1280*a(10)-3200*a(11) 

         f(5) = 192*a(6)+192*a(7)-1152*a(8)-1152*a(9)+4224*a(10)+
     >      4224*a(11)
         f(6) = 448*a(7)+448*a(8)-3136*a(9)-3136*a(10)+
     >      12992*a(11)
         f(7) = 1024*a(8)+1024*a(9)-8192*a(10)-
     >      8192*a(11)
         f(8) = 2304*a(9)+2304*a(10)-20736*a(11) 

         f(9) = 5120*a(10)+5120*a(11)
         f(10) = 11264*a(11) 

      case(12)
         f(0) = a(1)+a(2)-a(3)-a(4)+2*a(5)+2*a(6)-
     >      2*a(7)-2*a(8)+3*a(9)+3*a(10)-3*a(11)-3*a(12) 

         f(1) = 4*a(2)+4*a(3)-8*a(4)-8*a(5)+16*a(6)+16*a(7)-
     >      24*a(8)-24*a(9)+36*a(10)+36*a(11)-48*a(12) 

         f(2) = 12*a(3)+12*a(4)-36*a(5)-36*a(6)+84*a(7)+84*a(8)-
     >      156*a(9)-156*a(10)+264*a(11)+264*a(12) 

         f(3) = 32*a(4)+32*a(5)-128*a(6)-128*a(7)+352*a(8)+
     >      352*a(9)-768*a(10)-768*a(11)+1472*a(12) 

         f(4) = 80*a(5)+80*a(6)-400*a(7)-400*a(8)+1280*a(9)+
     >      1280*a(10)-3200*a(11)-3200*a(12) 

         f(5) = 192*a(6)+192*a(7)-1152*a(8)-1152*a(9)+4224*a(10)+
     >      4224*a(11)-11904*a(12) 

         f(6) = 448*a(7)+448*a(8)-3136*a(9)-3136*a(10)+12992*a(11)+
     >      12992*a(12)
         f(7) = 1024*a(8)+1024*a(9)-8192*a(10)-
     >      8192*a(11)+37888*a(12) 

         f(8) = 2304*a(9)+2304*a(10)-20736*a(11)-20736*a(12) 

         f(9) = 5120*a(10)+5120*a(11)-51200*a(12) 

         f(10) = 11264*a(11)+11264*a(12)
         f(11) = 24576*a(12) 

      case(13)
         f(0) = a(1)+a(2)-a(3)-a(4)+2*a(5)+2*a(6)-
     >      2*a(7)-2*a(8)+3*a(9)+3*a(10)-3*a(11)-3*a(12)+4*a(13) 

         f(1) = 4*a(2)+4*a(3)-8*a(4)-8*a(5)+16*a(6)+16*a(7)-
     >      24*a(8)-24*a(9)+36*a(10)+36*a(11)-48*a(12)-48*a(13) 

         f(2) = 12*a(3)+12*a(4)-36*a(5)-36*a(6)+84*a(7)+84*a(8)-
     >      156*a(9)-156*a(10)+264*a(11)+264*a(12)-408*a(13) 

         f(3) = 32*a(4)+32*a(5)-128*a(6)-128*a(7)+352*a(8)+
     >      352*a(9)-768*a(10)-768*a(11)+1472*a(12)+1472*a(13) 

         f(4) = 80*a(5)+80*a(6)-400*a(7)-400*a(8)+1280*a(9)+
     >      1280*a(10)-3200*a(11)-3200*a(12)+6880*a(13) 

         f(5) = 192*a(6)+192*a(7)-1152*a(8)-1152*a(9)+4224*a(10)+
     >      4224*a(11)-11904*a(12)-11904*a(13) 

         f(6) = 448*a(7)+448*a(8)-3136*a(9)-3136*a(10)+12992*a(11)+
     >      12992*a(12)-40768*a(13) 

         f(7) = 1024*a(8)+1024*a(9)-8192*a(10)-8192*a(11)+
     >      37888*a(12)+37888*a(13) 

         f(8) = 2304*a(9)+2304*a(10)-20736*a(11)-20736*a(12)+
     >      105984*a(13)
         f(9) = 
     >      5120*a(10)+5120*a(11)-51200*a(12)-51200*a(13) 

         f(10) = 11264*a(11)+11264*a(12)-123904*a(13) 

         f(11) = 24576*a(12)+24576*a(13)
         f(12) = 53248*a(13) 

      case(14)
         f(0) = a(1)+a(2)-a(3)-a(4)+2*a(5)+2*a(6)-
     >      2*a(7)-2*a(8)+3*a(9)+3*a(10)-3*a(11)-3*a(12)+4*a(13)+
     >      4*a(14)
         f(1) = 4*a(2)+4*a(3)-8*a(4)-8*a(5)+16*a(6)+
     >      16*a(7)-24*a(8)-24*a(9)+36*a(10)+36*a(11)-48*a(12)-
     >      48*a(13)+64*a(14)
         f(2) = 
     >      12*a(3)+12*a(4)-36*a(5)-36*a(6)+84*a(7)+84*a(8)-156*a(9)-
     >      156*a(10)+264*a(11)+264*a(12)-408*a(13)-408*a(14) 

         f(3) = 32*a(4)+32*a(5)-128*a(6)-128*a(7)+352*a(8)+
     >      352*a(9)-768*a(10)-768*a(11)+1472*a(12)+1472*a(13)-
     >      2560*a(14)
         f(4) = 80*a(5)+80*a(6)-400*a(7)-400*a(8)+
     >      1280*a(9)+1280*a(10)-3200*a(11)-3200*a(12)+6880*a(13)+
     >      6880*a(14)
         f(5) = 192*a(6)+192*a(7)-1152*a(8)-1152*a(9)+
     >      4224*a(10)+4224*a(11)-11904*a(12)-11904*a(13)+28416*a(14) 

         f(6) = 448*a(7)+448*a(8)-3136*a(9)-3136*a(10)+12992*a(11)+
     >      12992*a(12)-40768*a(13)-40768*a(14) 

         f(7) = 1024*a(8)+1024*a(9)-8192*a(10)-8192*a(11)+
     >      37888*a(12)+37888*a(13)-131072*a(14) 

         f(8) = 2304*a(9)+2304*a(10)-20736*a(11)-20736*a(12)+
     >      105984*a(13)+105984*a(14) 

         f(9) = 5120*a(10)+5120*a(11)-51200*a(12)-51200*a(13)+
     >      286720*a(14)
         f(10) = 
     >      11264*a(11)+11264*a(12)-123904*a(13)-123904*a(14) 

         f(11) = 24576*a(12)+24576*a(13)-294912*a(14) 

         f(12) = 53248*a(13)+53248*a(14)
         f(13) = 114688*a(14) 

      case(15)
         f(0) = a(1)+a(2)-a(3)-a(4)+2*a(5)+2*a(6)-
     >      2*a(7)-2*a(8)+3*a(9)+3*a(10)-3*a(11)-3*a(12)+4*a(13)+
     >      4*a(14)-4*a(15)
         f(1) = 
     >      4*a(2)+4*a(3)-8*a(4)-8*a(5)+16*a(6)+16*a(7)-24*a(8)-
     >      24*a(9)+36*a(10)+36*a(11)-48*a(12)-48*a(13)+64*a(14)+
     >      64*a(15)
         f(2) = 12*a(3)+12*a(4)-36*a(5)-36*a(6)+84*a(7)+
     >      84*a(8)-156*a(9)-156*a(10)+264*a(11)+264*a(12)-408*a(13)-
     >      408*a(14)+600*a(15)
         f(3) = 
     >      32*a(4)+32*a(5)-128*a(6)-128*a(7)+352*a(8)+352*a(9)-
     >      768*a(10)-768*a(11)+1472*a(12)+1472*a(13)-2560*a(14)-
     >      2560*a(15)
         f(4) = 80*a(5)+80*a(6)-400*a(7)-400*a(8)+
     >      1280*a(9)+1280*a(10)-3200*a(11)-3200*a(12)+6880*a(13)+
     >      6880*a(14)-13280*a(15) 

         f(5) = 192*a(6)+192*a(7)-1152*a(8)-1152*a(9)+4224*a(10)+
     >      4224*a(11)-11904*a(12)-11904*a(13)+28416*a(14)+28416*a(15) 

         f(6) = 448*a(7)+448*a(8)-3136*a(9)-3136*a(10)+12992*a(11)+
     >      12992*a(12)-40768*a(13)-40768*a(14)+107072*a(15) 

         f(7) = 1024*a(8)+1024*a(9)-8192*a(10)-8192*a(11)+
     >      37888*a(12)+37888*a(13)-131072*a(14)-131072*a(15) 

         f(8) = 2304*a(9)+2304*a(10)-20736*a(11)-20736*a(12)+
     >      105984*a(13)+105984*a(14)-400896*a(15) 

         f(9) = 5120*a(10)+5120*a(11)-51200*a(12)-51200*a(13)+
     >      286720*a(14)+286720*a(15) 

         f(10) = 11264*a(11)+11264*a(12)-123904*a(13)-123904*a(14)+
     >      754688*a(15)
         f(11) = 
     >      24576*a(12)+24576*a(13)-294912*a(14)-294912*a(15) 

         f(12) = 53248*a(13)+53248*a(14)-692224*a(15) 

         f(13) = 114688*a(14)+114688*a(15)
         f(14) = 245760*a(15)

      case default
         stop ' coef0: statement is missing for Nl>15 at l=1'
      end select
      
*     10 d states
      case(2)                   ! for d states
      select case(Nl)

      case(1)
         f(0) = a(1)
      case(2) 

         f(0) = a(1)+a(2)
         f(1) = 6*a(2) 

      case(3)
         f(0) = a(1)+a(2)-2*a(3)
         f(1) = 6*a(2)+6*a(3) 

         f(2) = 24*a(3)
      case(4) 

         f(0) = a(1)+a(2)-2*a(3)-2*a(4) 

         f(1) = 6*a(2)+6*a(3)-18*a(4)
         f(2) = 24*a(3)+24*a(4) 

         f(3) = 80*a(4)
      case(5) 

         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+4*a(5) 

         f(1) = 6*a(2)+6*a(3)-18*a(4)-18*a(5) 

         f(2) = 24*a(3)+24*a(4)-96*a(5)
         f(3) = 80*a(4)+80*a(5) 

         f(4) = 240*a(5)
      case(6) 

         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+4*a(5)+4*a(6) 

         f(1) = 6*a(2)+6*a(3)-18*a(4)-18*a(5)+42*a(6) 

         f(2) = 24*a(3)+24*a(4)-96*a(5)-96*a(6) 

         f(3) = 80*a(4)+80*a(5)-400*a(6)
         f(4) = 240*a(5)+240*a(6) 

         f(5) = 672*a(6)
      case(7) 

         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+4*a(5)+4*a(6)-6*a(7) 

         f(1) = 6*a(2)+6*a(3)-18*a(4)-18*a(5)+42*a(6)+42*a(7) 

         f(2) = 24*a(3)+24*a(4)-96*a(5)-96*a(6)+264*a(7) 

         f(3) = 80*a(4)+80*a(5)-400*a(6)-400*a(7) 

         f(4) = 240*a(5)+240*a(6)-1440*a(7) 

         f(5) = 672*a(6)+672*a(7)
         f(6) = 1792*a(7) 

      case(8)
         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+4*a(5)+4*a(6)-
     >      6*a(7)-6*a(8)
         f(1) = 
     >      6*a(2)+6*a(3)-18*a(4)-18*a(5)+42*a(6)+42*a(7)-78*a(8) 

         f(2) = 24*a(3)+24*a(4)-96*a(5)-96*a(6)+264*a(7)+264*a(8) 

         f(3) = 80*a(4)+80*a(5)-400*a(6)-400*a(7)+1280*a(8) 

         f(4) = 240*a(5)+240*a(6)-1440*a(7)-1440*a(8) 

         f(5) = 672*a(6)+672*a(7)-4704*a(8) 

         f(6) = 1792*a(7)+1792*a(8)
         f(7) = 4608*a(8) 

      case(9)
         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+4*a(5)+4*a(6)-
     >      6*a(7)-6*a(8)+9*a(9) 

         f(1) = 6*a(2)+6*a(3)-18*a(4)-18*a(5)+42*a(6)+42*a(7)-
     >      78*a(8)-78*a(9)
         f(2) = 
     >      24*a(3)+24*a(4)-96*a(5)-96*a(6)+264*a(7)+264*a(8)-576*a(9)

         f(3) = 80*a(4)+80*a(5)-400*a(6)-400*a(7)+1280*a(8)+
     >      1280*a(9)
         f(4) = 240*a(5)+240*a(6)-1440*a(7)-1440*a(8)+
     >      5280*a(9)
         f(5) = 672*a(6)+672*a(7)-4704*a(8)-4704*a(9) 

         f(6) = 1792*a(7)+1792*a(8)-14336*a(9) 

         f(7) = 4608*a(8)+4608*a(9)
         f(8) = 11520*a(9) 

      case(10)
         f(0) = a(1)+a(2)-2*a(3)-2*a(4)+4*a(5)+4*a(6)-
     >      6*a(7)-6*a(8)+9*a(9)+9*a(10) 

         f(1) = 6*a(2)+6*a(3)-18*a(4)-18*a(5)+42*a(6)+42*a(7)-
     >      78*a(8)-78*a(9)+132*a(10) 

         f(2) = 24*a(3)+24*a(4)-96*a(5)-96*a(6)+264*a(7)+264*a(8)-
     >      576*a(9)-576*a(10)
         f(3) = 
     >      80*a(4)+80*a(5)-400*a(6)-400*a(7)+1280*a(8)+1280*a(9)-
     >      3200*a(10)
         f(4) = 240*a(5)+240*a(6)-1440*a(7)-1440*a(8)+
     >      5280*a(9)+5280*a(10)
         f(5) = 
     >      672*a(6)+672*a(7)-4704*a(8)-4704*a(9)+19488*a(10) 

         f(6) = 1792*a(7)+1792*a(8)-14336*a(9)-14336*a(10) 

         f(7) = 4608*a(8)+4608*a(9)-41472*a(10) 

         f(8) = 11520*a(9)+11520*a(10)
         f(9) = 28160*a(10)

      case default
         stop ' coef0: statement is missing for Nl>10 at l=2'
      end select
      
*     10 f states
      case(3)                   ! for f states
      select case(Nl)

      case(1)
         f(0) = a(1)
      case(2) 

         f(0) = a(1)+a(2)
         f(1) = 8*a(2) 

      case(3)
         f(0) = a(1)+a(2)-3*a(3)
         f(1) = 8*a(2)+8*a(3) 

         f(2) = 40*a(3)
      case(4) 

         f(0) = a(1)+a(2)-3*a(3)-3*a(4) 

         f(1) = 8*a(2)+8*a(3)-32*a(4)
         f(2) = 40*a(3)+40*a(4) 

         f(3) = 160*a(4)
      case(5) 

         f(0) = a(1)+a(2)-3*a(3)-3*a(4)+7*a(5) 

         f(1) = 8*a(2)+8*a(3)-32*a(4)-32*a(5) 

         f(2) = 40*a(3)+40*a(4)-200*a(5)
         f(3) = 160*a(4)+160*a(5) 

         f(4) = 560*a(5)
      case(6) 

         f(0) = a(1)+a(2)-3*a(3)-3*a(4)+7*a(5)+7*a(6) 

         f(1) = 8*a(2)+8*a(3)-32*a(4)-32*a(5)+88*a(6) 

         f(2) = 40*a(3)+40*a(4)-200*a(5)-200*a(6) 

         f(3) = 160*a(4)+160*a(5)-960*a(6) 

         f(4) = 560*a(5)+560*a(6)
         f(5) = 1792*a(6) 

      case(7)
         f(0) = a(1)+a(2)-3*a(3)-3*a(4)+7*a(5)+7*a(6)-
     >      13*a(7)
         f(1) = 8*a(2)+8*a(3)-32*a(4)-32*a(5)+88*a(6)+
     >      88*a(7)
         f(2) = 40*a(3)+40*a(4)-200*a(5)-200*a(6)+
     >      640*a(7)
         f(3) = 160*a(4)+160*a(5)-960*a(6)-960*a(7) 

         f(4) = 560*a(5)+560*a(6)-3920*a(7) 

         f(5) = 1792*a(6)+1792*a(7)
         f(6) = 5376*a(7) 

      case(8)
         f(0) = a(1)+a(2)-3*a(3)-3*a(4)+7*a(5)+7*a(6)-
     >      13*a(7)-13*a(8)
         f(1) = 
     >      8*a(2)+8*a(3)-32*a(4)-32*a(5)+88*a(6)+88*a(7)-192*a(8) 

         f(2) = 40*a(3)+40*a(4)-200*a(5)-200*a(6)+640*a(7)+
     >      640*a(8)
         f(3) = 160*a(4)+160*a(5)-960*a(6)-960*a(7)+
     >      3520*a(8)
         f(4) = 560*a(5)+560*a(6)-3920*a(7)-3920*a(8) 

         f(5) = 1792*a(6)+1792*a(7)-14336*a(8) 

         f(6) = 5376*a(7)+5376*a(8)
         f(7) = 15360*a(8) 

      case(9)
         f(0) = a(1)+a(2)-3*a(3)-3*a(4)+7*a(5)+7*a(6)-
     >      13*a(7)-13*a(8)+22*a(9) 

         f(1) = 8*a(2)+8*a(3)-32*a(4)-32*a(5)+88*a(6)+88*a(7)-
     >      192*a(8)-192*a(9)
         f(2) = 
     >      40*a(3)+40*a(4)-200*a(5)-200*a(6)+640*a(7)+640*a(8)-
     >      1600*a(9)
         f(3) = 160*a(4)+160*a(5)-960*a(6)-960*a(7)+
     >      3520*a(8)+3520*a(9)
         f(4) = 
     >      560*a(5)+560*a(6)-3920*a(7)-3920*a(8)+16240*a(9) 

         f(5) = 1792*a(6)+1792*a(7)-14336*a(8)-14336*a(9) 

         f(6) = 5376*a(7)+5376*a(8)-48384*a(9) 

         f(7) = 15360*a(8)+15360*a(9)
         f(8) = 42240*a(9) 

      case(10)
         f(0) = a(1)+a(2)-3*a(3)-3*a(4)+7*a(5)+7*a(6)-
     >      13*a(7)-13*a(8)+22*a(9)+22*a(10) 

         f(1) = 8*a(2)+8*a(3)-32*a(4)-32*a(5)+88*a(6)+88*a(7)-
     >      192*a(8)-192*a(9)+368*a(10) 

         f(2) = 40*a(3)+40*a(4)-200*a(5)-200*a(6)+640*a(7)+
     >      640*a(8)-1600*a(9)-1600*a(10) 

         f(3) = 160*a(4)+160*a(5)-960*a(6)-960*a(7)+3520*a(8)+
     >      3520*a(9)-9920*a(10)
         f(4) = 
     >      560*a(5)+560*a(6)-3920*a(7)-3920*a(8)+16240*a(9)+16240*a(10) 

         f(5) = 1792*a(6)+1792*a(7)-14336*a(8)-14336*a(9)+66304*a(10) 

         f(6) = 5376*a(7)+5376*a(8)-48384*a(9)-48384*a(10) 

         f(7) = 15360*a(8)+15360*a(9)-153600*a(10) 

         f(8) = 42240*a(9)+42240*a(10)
         f(9) = 112640*a(10)
      case default
         stop ' coef0: statement is missing for Nl>10 at l=3'
      end select
    
      case default
         stop ' coef0: statement is missing for ll>3'
      end select
      return
      end
      
************************************************************************

      subroutine dqawfe(f,a,omega,integr,epsabs,limlst,limit,maxp1,
     *   result,abserr,neval,ier,rslst,erlst,ierlst,lst,alist,blist,
     *   rlist,elist,iord,nnlog,chebmo)
c***begin prologue  dqawfe
c***date written   800101   (yymmdd)
c***revision date  830518   (yymmdd)
c***category no.  h2a3a1
c***keywords  automatic integrator, special-purpose,
c             fourier integrals,
c             integration between zeros with dqawoe,
c             convergence acceleration with dqelg
c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
c           dedoncker,elise,appl. math. & progr. div. - k.u.leuven
c***purpose  the routine calculates an approximation result to a
c            given fourier integal
c            i = integral of f(x)*w(x) over (a,infinity)
c            where w(x)=cos(omega*x) or w(x)=sin(omega*x),
c            hopefully satisfying following claim for accuracy
c            abs(i-result).le.epsabs.
c***description
c
c        computation of fourier integrals
c        standard fortran subroutine
c        double precision version
c
c        parameters
c         on entry
c            f      - double precision
c                     function subprogram defining the integrand
c                     function f(x). the actual name for f needs to
c                     be declared e x t e r n a l in the driver program.
c
c            a      - double precision
c                     lower limit of integration
c
c            omega  - double precision
c                     parameter in the weight function
c
c            integr - integer
c                     indicates which weight function is used
c                     integr = 1      w(x) = cos(omega*x)
c                     integr = 2      w(x) = sin(omega*x)
c                     if integr.ne.1.and.integr.ne.2, the routine will
c                     end with ier = 6.
c
c            epsabs - double precision
c                     absolute accuracy requested, epsabs.gt.0
c                     if epsabs.le.0, the routine will end with ier = 6.
c
c            limlst - integer
c                     limlst gives an upper bound on the number of
c                     cycles, limlst.ge.1.
c                     if limlst.lt.3, the routine will end with ier = 6.
c
c            limit  - integer
c                     gives an upper bound on the number of subintervals
c                     allowed in the partition of each cycle, limit.ge.1
c                     each cycle, limit.ge.1.
c
c            maxp1  - integer
c                     gives an upper bound on the number of
c                     chebyshev moments which can be stored, i.e.
c                     for the intervals of lengths abs(b-a)*2**(-l),
c                     l=0,1, ..., maxp1-2, maxp1.ge.1
c
c         on return
c            result - double precision
c                     approximation to the integral x
c
c            abserr - double precision
c                     estimate of the modulus of the absolute error,
c                     which should equal or exceed abs(i-result)
c
c            neval  - integer
c                     number of integrand evaluations
c
c            ier    - ier = 0 normal and reliable termination of
c                             the routine. it is assumed that the
c                             requested accuracy has been achieved.
c                     ier.gt.0 abnormal termination of the routine. the
c                             estimates for integral and error are less
c                             reliable. it is assumed that the requested
c                             accuracy has not been achieved.
c            error messages
c                    if omega.ne.0
c                     ier = 1 maximum number of  cycles  allowed
c                             has been achieved., i.e. of subintervals
c                             (a+(k-1)c,a+kc) where
c                             c = (2*int(abs(omega))+1)*pi/abs(omega),
c                             for k = 1, 2, ..., lst.
c                             one can allow more cycles by increasing
c                             the value of limlst (and taking the
c                             according dimension adjustments into
c                             account).
c                             examine the array iwork which contains
c                             the error flags on the cycles, in order to
c                             look for eventual local integration
c                             difficulties. if the position of a local
c                             difficulty can be determined (e.g.
c                             singularity, discontinuity within the
c                             interval) one will probably gain from
c                             splitting up the interval at this point
c                             and calling appropriate integrators on
c                             the subranges.
c                         = 4 the extrapolation table constructed for
c                             convergence acceleration of the series
c                             formed by the integral contributions over
c                             the cycles, does not converge to within
c                             the requested accuracy. as in the case of
c                             ier = 1, it is advised to examine the
c                             array iwork which contains the error
c                             flags on the cycles.
c                         = 6 the input is invalid because
c                             (integr.ne.1 and integr.ne.2) or
c                              epsabs.le.0 or limlst.lt.3.
c                              result, abserr, neval, lst are set
c                              to zero.
c                         = 7 bad integrand behaviour occurs within one
c                             or more of the cycles. location and type
c                             of the difficulty involved can be
c                             determined from the vector ierlst. here
c                             lst is the number of cycles actually
c                             needed (see below).
c                             ierlst(k) = 1 the maximum number of
c                                           subdivisions (= limit) has
c                                           been achieved on the k th
c                                           cycle.
c                                       = 2 occurrence of roundoff error
c                                           is detected and prevents the
c                                           tolerance imposed on the
c                                           k th cycle, from being
c                                           achieved.
c                                       = 3 extremely bad integrand
c                                           behaviour occurs at some
c                                           points of the k th cycle.
c                                       = 4 the integration procedure
c                                           over the k th cycle does
c                                           not converge (to within the
c                                           required accuracy) due to
c                                           roundoff in the
c                                           extrapolation procedure
c                                           invoked on this cycle. it
c                                           is assumed that the result
c                                           on this interval is the
c                                           best which can be obtained.
c                                       = 5 the integral over the k th
c                                           cycle is probably divergent
c                                           or slowly convergent. it
c                                           must be noted that
c                                           divergence can occur with
c                                           any other value of
c                                           ierlst(k).
c                    if omega = 0 and integr = 1,
c                    the integral is calculated by means of dqagie1
c                    and ier = ierlst(1) (with meaning as described
c                    for ierlst(k), k = 1).
c
c            rslst  - double precision
c                     vector of dimension at least limlst
c                     rslst(k) contains the integral contribution
c                     over the interval (a+(k-1)c,a+kc) where
c                     c = (2*int(abs(omega))+1)*pi/abs(omega),
c                     k = 1, 2, ..., lst.
c                     note that, if omega = 0, rslst(1) contains
c                     the value of the integral over (a,infinity).
c
c            erlst  - double precision
c                     vector of dimension at least limlst
c                     erlst(k) contains the error estimate corresponding
c                     with rslst(k).
c
c            ierlst - integer
c                     vector of dimension at least limlst
c                     ierlst(k) contains the error flag corresponding
c                     with rslst(k). for the meaning of the local error
c                     flags see description of output parameter ier.
c
c            lst    - integer
c                     number of subintervals needed for the integration
c                     if omega = 0 then lst is set to 1.
c
c            alist, blist, rlist, elist - double precision
c                     vector of dimension at least limit,
c
c            iord, nnlog - integer
c                     vector of dimension at least limit, providing
c                     space for the quantities needed in the subdivision
c                     process of each cycle
c
c            chebmo - double precision
c                     array of dimension at least (maxp1,25), providing
c                     space for the chebyshev moments needed within the
c                     cycles
c
c***references  (none)
c***routines called  d1mach,dqagie1,dqawoe,dqelg
c***end prologue  dqawfe
c
      double precision a,abseps,abserr,alist,blist,chebmo,correc,cycle,
     *  c1,c2,dabs,dl,dla,dmax1,drl,d1mach,elist,erlst,ep,eps,epsa,
     *  epsabs,errsum,f,fact,omega,p,pi,p1,psum,reseps,result,res3la,
     *  rlist,rslst,uflow
      integer ier,ierlst,integr,iord,ktmin,l,last,lst,limit,limlst,ll,
     *    maxp1,momcom,nev,neval,nnlog,nres,numrl2
c
      dimension alist(limit),blist(limit),chebmo(maxp1,25),elist(limit),
     *  erlst(limlst),ierlst(limlst),iord(limit),nnlog(limit),psum(52),
     *  res3la(3),rlist(limit),rslst(limlst)
c
      external f
c
c
c            the dimension of  psum  is determined by the value of
c            limexp in subroutine dqelg (psum must be of dimension
c            (limexp+2) at least).
c
c           list of major variables
c           -----------------------
c
c           c1, c2    - end points of subinterval (of length cycle)
c           cycle     - (2*int(abs(omega))+1)*pi/abs(omega)
c           psum      - vector of dimension at least (limexp+2)
c                       (see routine dqelg)
c                       psum contains the part of the epsilon table
c                       which is still needed for further computations.
c                       each element of psum is a partial sum of the
c                       series which should sum to the value of the
c                       integral.
c           errsum    - sum of error estimates over the subintervals,
c                       calculated cumulatively
c           epsa      - absolute tolerance requested over current
c                       subinterval
c           chebmo    - array containing the modified chebyshev
c                       moments (see also routine dqc25f)
c
      data p/0.9d+00/
      data pi / 3.1415926535 8979323846 2643383279 50 d0 /
c
c           test on validity of parameters
c           ------------------------------
c
c***first executable statement  dqawfe
      result = 0.0d+00
      abserr = 0.0d+00
      neval = 0
      lst = 0
      ier = 0
      if((integr.ne.1.and.integr.ne.2).or.epsabs.le.0.0d+00.or.
     *  limlst.lt.3) ier = 6
      if(ier.eq.6) go to 999
      if(omega.ne.0.0d+00) go to 10
c
c           integration by dqagie1 if omega is zero
c           --------------------------------------
c
      if(integr.eq.1) call dqagie1(f,a,1,epsabs,0.0d+00,limit,
     *  result,abserr,neval,ier,alist,blist,rlist,elist,iord,last)
      rslst(1) = result
      erlst(1) = abserr
      ierlst(1) = ier
      lst = 1
      go to 999
c
c           initializations
c           ---------------
c
   10 l = dabs(omega)
      dl = 2*l+1
      cycle = dl*pi/dabs(omega)
      ier = 0
      ktmin = 0
      neval = 0
      numrl2 = 0
      nres = 0
      c1 = a
      c2 = cycle+a
      p1 = 0.1d+01-p
      uflow = d1mach(1)
      eps = epsabs
      if(epsabs.gt.uflow/p1) eps = epsabs*p1
      ep = eps
      fact = 0.1d+01
      correc = 0.0d+00
      abserr = 0.0d+00
      errsum = 0.0d+00
c
c           main do-loop
c           ------------
c
      do 50 lst = 1,limlst
c
c           integrate over current subinterval.
c
        dla = lst
        epsa = eps*fact
        call dqawoe(f,c1,c2,omega,integr,epsa,0.0d+00,limit,lst,maxp1,
     *  rslst(lst),erlst(lst),nev,ierlst(lst),last,alist,blist,rlist,
     *  elist,iord,nnlog,momcom,chebmo)
        neval = neval+nev
        fact = fact*p
        errsum = errsum+erlst(lst)
        drl = 0.5d+02*dabs(rslst(lst))
c
c           test on accuracy with partial sum
c
        if((errsum+drl).le.epsabs.and.lst.ge.6) go to 80
        correc = dmax1(correc,erlst(lst))
        if(ierlst(lst).ne.0) eps = dmax1(ep,correc*p1)
        if(ierlst(lst).ne.0) ier = 7
        if(ier.eq.7.and.(errsum+drl).le.correc*0.1d+02.and.
     *  lst.gt.5) go to 80
        numrl2 = numrl2+1
        if(lst.gt.1) go to 20
        psum(1) = rslst(1)
        go to 40
   20   psum(numrl2) = psum(ll)+rslst(lst)
        if(lst.eq.2) go to 40
c
c           test on maximum number of subintervals
c
        if(lst.eq.limlst) ier = 1
c
c           perform new extrapolation
c
        call dqelg(numrl2,psum,reseps,abseps,res3la,nres)
c
c           test whether extrapolated result is influenced by roundoff
c
        ktmin = ktmin+1
        if(ktmin.ge.15.and.abserr.le.0.1d-02*(errsum+drl)) ier = 4
        if(abseps.gt.abserr.and.lst.ne.3) go to 30
        abserr = abseps
        result = reseps
        ktmin = 0
c
c           if ier is not 0, check whether direct result (partial sum)
c           or extrapolated result yields the best integral
c           approximation
c
        if((abserr+0.1d+02*correc).le.epsabs.or.
     *  (abserr.le.epsabs.and.0.1d+02*correc.ge.epsabs)) go to 60
   30   if(ier.ne.0.and.ier.ne.7) go to 60
   40   ll = numrl2
        c1 = c2
        c2 = c2+cycle
   50 continue
c
c         set final result and error estimate
c         -----------------------------------
c
   60 abserr = abserr+0.1d+02*correc
      if(ier.eq.0) go to 999
      if(result.ne.0.0d+00.and.psum(numrl2).ne.0.0d+00) go to 70
      if(abserr.gt.errsum) go to 80
      if(psum(numrl2).eq.0.0d+00) go to 999
   70 if(abserr/dabs(result).gt.(errsum+drl)/dabs(psum(numrl2)))
     *  go to 80
      if(ier.ge.1.and.ier.ne.7) abserr = abserr+drl
      go to 999
   80 result = psum(numrl2)
      abserr = errsum+drl
  999 return
      end
      subroutine dqagie1(f,bound,inf,epsabs,epsrel,limit,result,abserr,
     *   neval,ier,alist,blist,rlist,elist,iord,last)
c***begin prologue  dqagie1
c***date written   800101   (yymmdd)
c***revision date  830518   (yymmdd)
c***category no.  h2a3a1,h2a4a1
c***keywords  automatic integrator, infinite intervals,
c             general-purpose, transformation, extrapolation,
c             globally adaptive
c***author  piessens,robert,appl. math & progr. div - k.u.leuven
c           de doncker,elise,appl. math & progr. div - k.u.leuven
c***purpose  the routine calculates an approximation result to a given
c            integral   i = integral of f over (bound,+infinity)
c            or i = integral of f over (-infinity,bound)
c            or i = integral of f over (-infinity,+infinity),
c            hopefully satisfying following claim for accuracy
c            abs(i-result).le.max(epsabs,epsrel*abs(i))
c***description
c
c integration over infinite intervals
c standard fortran subroutine
c
c            f      - double precision
c                     function subprogram defining the integrand
c                     function f(x). the actual name for f needs to be
c                     declared e x t e r n a l in the driver program.
c
c            bound  - double precision
c                     finite bound of integration range
c                     (has no meaning if interval is doubly-infinite)
c
c            inf    - double precision
c                     indicating the kind of integration range involved
c                     inf = 1 corresponds to  (bound,+infinity),
c                     inf = -1            to  (-infinity,bound),
c                     inf = 2             to (-infinity,+infinity).
c
c            epsabs - double precision
c                     absolute accuracy requested
c            epsrel - double precision
c                     relative accuracy requested
c                     if  epsabs.le.0
c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
c                     the routine will end with ier = 6.
c
c            limit  - integer
c                     gives an upper bound on the number of subintervals
c                     in the partition of (a,b), limit.ge.1
c
c         on return
c            result - double precision
c                     approximation to the integral
c
c            abserr - double precision
c                     estimate of the modulus of the absolute error,
c                     which should equal or exceed abs(i-result)
c
c            neval  - integer
c                     number of integrand evaluations
c
c            ier    - integer
c                     ier = 0 normal and reliable termination of the
c                             routine. it is assumed that the requested
c                             accuracy has been achieved.
c                   - ier.gt.0 abnormal termination of the routine. the
c                             estimates for result and error are less
c                             reliable. it is assumed that the requested
c                             accuracy has not been achieved.
c            error messages
c                     ier = 1 maximum number of subdivisions allowed
c                             has been achieved. one can allow more
c                             subdivisions by increasing the value of
c                             limit (and taking the according dimension
c                             adjustments into account). however,if
c                             this yields no improvement it is advised
c                             to analyze the integrand in order to
c                             determine the integration difficulties.
c                             if the position of a local difficulty can
c                             be determined (e.g. singularity,
c                             discontinuity within the interval) one
c                             will probably gain from splitting up the
c                             interval at this point and calling the
c                             integrator on the subranges. if possible,
c                             an appropriate special-purpose integrator
c                             should be used, which is designed for
c                             handling the type of difficulty involved.
c                         = 2 the occurrence of roundoff error is
c                             detected, which prevents the requested
c                             tolerance from being achieved.
c                             the error may be under-estimated.
c                         = 3 extremely bad integrand behaviour occurs
c                             at some points of the integration
c                             interval.
c                         = 4 the algorithm does not converge.
c                             roundoff error is detected in the
c                             extrapolation table.
c                             it is assumed that the requested tolerance
c                             cannot be achieved, and that the returned
c                             result is the best which can be obtained.
c                         = 5 the integral is probably divergent, or
c                             slowly convergent. it must be noted that
c                             divergence can occur with any other value
c                             of ier.
c                         = 6 the input is invalid, because
c                             (epsabs.le.0 and
c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
c                             result, abserr, neval, last, rlist(1),
c                             elist(1) and iord(1) are set to zero.
c                             alist(1) and blist(1) are set to 0
c                             and 1 respectively.
c
c            alist  - double precision
c                     vector of dimension at least limit, the first
c                      last  elements of which are the left
c                     end points of the subintervals in the partition
c                     of the transformed integration range (0,1).
c
c            blist  - double precision
c                     vector of dimension at least limit, the first
c                      last  elements of which are the right
c                     end points of the subintervals in the partition
c                     of the transformed integration range (0,1).
c
c            rlist  - double precision
c                     vector of dimension at least limit, the first
c                      last  elements of which are the integral
c                     approximations on the subintervals
c
c            elist  - double precision
c                     vector of dimension at least limit,  the first
c                     last elements of which are the moduli of the
c                     absolute error estimates on the subintervals
c
c            iord   - integer
c                     vector of dimension limit, the first k
c                     elements of which are pointers to the
c                     error estimates over the subintervals,
c                     such that elist(iord(1)), ..., elist(iord(k))
c                     form a decreasing sequence, with k = last
c                     if last.le.(limit/2+2), and k = limit+1-last
c                     otherwise
c
c            last   - integer
c                     number of subintervals actually produced
c                     in the subdivision process
c
c***references  (none)
c***routines called  d1mach,dqelg,dqk15i1,dqpsrt
c***end prologue  dqagie1
      double precision abseps,abserr,alist,area,area1,area12,area2,a1,
     *  a2,blist,boun,bound,b1,b2,correc,dabs,defabs,defab1,defab2,
     *  dmax1,dres,d1mach,elist,epmach,epsabs,epsrel,erlarg,erlast,
     *  errbnd,errmax,error1,error2,erro12,errsum,ertest,f,oflow,resabs,
     *  reseps,result,res3la,rlist,rlist2,small,uflow
      integer id,ier,ierro,inf,iord,iroff1,iroff2,iroff3,jupbnd,k,ksgn,
     *  ktmin,last,limit,maxerr,neval,nres,nrmax,numrl2
      logical extrap,noext
c
      dimension alist(limit),blist(limit),elist(limit),iord(limit),
     *  res3la(3),rlist(limit),rlist2(52)
c
      external f
c
c            the dimension of rlist2 is determined by the value of
c            limexp in subroutine dqelg.
c
c
c            list of major variables
c            -----------------------
c
c           alist     - list of left end points of all subintervals
c                       considered up to now
c           blist     - list of right end points of all subintervals
c                       considered up to now
c           rlist(i)  - approximation to the integral over
c                       (alist(i),blist(i))
c           rlist2    - array of dimension at least (limexp+2),
c                       containing the part of the epsilon table
c                       wich is still needed for further computations
c           elist(i)  - error estimate applying to rlist(i)
c           maxerr    - pointer to the interval with largest error
c                       estimate
c           errmax    - elist(maxerr)
c           erlast    - error on the interval currently subdivided
c                       (before that subdivision has taken place)
c           area      - sum of the integrals over the subintervals
c           errsum    - sum of the errors over the subintervals
c           errbnd    - requested accuracy max(epsabs,epsrel*
c                       abs(result))
c           *****1    - variable for the left subinterval
c           *****2    - variable for the right subinterval
c           last      - index for subdivision
c           nres      - number of calls to the extrapolation routine
c           numrl2    - number of elements currently in rlist2. if an
c                       appropriate approximation to the compounded
c                       integral has been obtained, it is put in
c                       rlist2(numrl2) after numrl2 has been increased
c                       by one.
c           small     - length of the smallest interval considered up
c                       to now, multiplied by 1.5
c           erlarg    - sum of the errors over the intervals larger
c                       than the smallest interval considered up to now
c           extrap    - logical variable denoting that the routine
c                       is attempting to perform extrapolation. i.e.
c                       before subdividing the smallest interval we
c                       try to decrease the value of erlarg.
c           noext     - logical variable denoting that extrapolation
c                       is no longer allowed (true-value)
c
c            machine dependent constants
c            ---------------------------
c
c           epmach is the largest relative spacing.
c           uflow is the smallest positive magnitude.
c           oflow is the largest positive magnitude.
c
c***first executable statement  dqagie1
       epmach = d1mach(4)
c
c           test on validity of parameters
c           -----------------------------
c
      ier = 0
      neval = 0
      last = 0
      result = 0.0d+00
      abserr = 0.0d+00
      alist(1) = 0.0d+00
      blist(1) = 0.1d+01
      rlist(1) = 0.0d+00
      elist(1) = 0.0d+00
      iord(1) = 0
      if(epsabs.le.0.0d+00.and.epsrel.lt.dmax1(0.5d+02*epmach,0.5d-28))
     *  ier = 6
       if(ier.eq.6) go to 999
c
c
c           first approximation to the integral
c           -----------------------------------
c
c           determine the interval to be mapped onto (0,1).
c           if inf = 2 the integral is computed as i = i1+i2, where
c           i1 = integral of f over (-infinity,0),
c           i2 = integral of f over (0,+infinity).
c
      boun = bound
      if(inf.eq.2) boun = 0.0d+00
      call dqk15i1(f,boun,inf,0.0d+00,0.1d+01,result,abserr,
     *  defabs,resabs)
c
c           test on accuracy
c
      last = 1
      rlist(1) = result
      elist(1) = abserr
      iord(1) = 1
      dres = dabs(result)
      errbnd = dmax1(epsabs,epsrel*dres)
      if(abserr.le.1.0d+02*epmach*defabs.and.abserr.gt.errbnd) ier = 2
      if(limit.eq.1) ier = 1
      if(ier.ne.0.or.(abserr.le.errbnd.and.abserr.ne.resabs).or.
     *  abserr.eq.0.0d+00) go to 130
c
c           initialization
c           --------------
c
      uflow = d1mach(1)
      oflow = d1mach(2)
      rlist2(1) = result
      errmax = abserr
      maxerr = 1
      area = result
      errsum = abserr
      abserr = oflow
      nrmax = 1
      nres = 0
      ktmin = 0
      numrl2 = 2
      extrap = .false.
      noext = .false.
      ierro = 0
      iroff1 = 0
      iroff2 = 0
      iroff3 = 0
      ksgn = -1
      if(dres.ge.(0.1d+01-0.5d+02*epmach)*defabs) ksgn = 1
c
c           main do-loop
c           ------------
c
      do 90 last = 2,limit
c
c           bisect the subinterval with nrmax-th largest error estimate.
c
        a1 = alist(maxerr)
        b1 = 0.5d+00*(alist(maxerr)+blist(maxerr))
        a2 = b1
        b2 = blist(maxerr)
        erlast = errmax
        call dqk15i1(f,boun,inf,a1,b1,area1,error1,resabs,defab1)
        call dqk15i1(f,boun,inf,a2,b2,area2,error2,resabs,defab2)
c
c           improve previous approximations to integral
c           and error and test for accuracy.
c
        area12 = area1+area2
        erro12 = error1+error2
        errsum = errsum+erro12-errmax
        area = area+area12-rlist(maxerr)
        if(defab1.eq.error1.or.defab2.eq.error2)go to 15
        if(dabs(rlist(maxerr)-area12).gt.0.1d-04*dabs(area12)
     *  .or.erro12.lt.0.99d+00*errmax) go to 10
        if(extrap) iroff2 = iroff2+1
        if(.not.extrap) iroff1 = iroff1+1
   10   if(last.gt.10.and.erro12.gt.errmax) iroff3 = iroff3+1
   15   rlist(maxerr) = area1
        rlist(last) = area2
        errbnd = dmax1(epsabs,epsrel*dabs(area))
c
c           test for roundoff error and eventually set error flag.
c
        if(iroff1+iroff2.ge.10.or.iroff3.ge.20) ier = 2
        if(iroff2.ge.5) ierro = 3
c
c           set error flag in the case that the number of
c           subintervals equals limit.
c
        if(last.eq.limit) ier = 1
c
c           set error flag in the case of bad integrand behaviour
c           at some points of the integration range.
c
        if(dmax1(dabs(a1),dabs(b2)).le.(0.1d+01+0.1d+03*epmach)*
     *  (dabs(a2)+0.1d+04*uflow)) ier = 4
c
c           append the newly-created intervals to the list.
c
        if(error2.gt.error1) go to 20
        alist(last) = a2
        blist(maxerr) = b1
        blist(last) = b2
        elist(maxerr) = error1
        elist(last) = error2
        go to 30
   20   alist(maxerr) = a2
        alist(last) = a1
        blist(last) = b1
        rlist(maxerr) = area2
        rlist(last) = area1
        elist(maxerr) = error2
        elist(last) = error1
c
c           call subroutine dqpsrt to maintain the descending ordering
c           in the list of error estimates and select the subinterval
c           with nrmax-th largest error estimate (to be bisected next).
c
   30   call dqpsrt(limit,last,maxerr,errmax,elist,iord,nrmax)
        if(errsum.le.errbnd) go to 115
        if(ier.ne.0) go to 100
        if(last.eq.2) go to 80
        if(noext) go to 90
        erlarg = erlarg-erlast
        if(dabs(b1-a1).gt.small) erlarg = erlarg+erro12
        if(extrap) go to 40
c
c           test whether the interval to be bisected next is the
c           smallest interval.
c
        if(dabs(blist(maxerr)-alist(maxerr)).gt.small) go to 90
        extrap = .true.
        nrmax = 2
   40   if(ierro.eq.3.or.erlarg.le.ertest) go to 60
c
c           the smallest interval has the largest error.
c           before bisecting decrease the sum of the errors over the
c           larger intervals (erlarg) and perform extrapolation.
c
        id = nrmax
        jupbnd = last
        if(last.gt.(2+limit/2)) jupbnd = limit+3-last
        do 50 k = id,jupbnd
          maxerr = iord(nrmax)
          errmax = elist(maxerr)
          if(dabs(blist(maxerr)-alist(maxerr)).gt.small) go to 90
          nrmax = nrmax+1
   50   continue
c
c           perform extrapolation.
c
   60   numrl2 = numrl2+1
        rlist2(numrl2) = area
        call dqelg(numrl2,rlist2,reseps,abseps,res3la,nres)
        ktmin = ktmin+1
        if(ktmin.gt.5.and.abserr.lt.0.1d-02*errsum) ier = 5
        if(abseps.ge.abserr) go to 70
        ktmin = 0
        abserr = abseps
        result = reseps
        correc = erlarg
        ertest = dmax1(epsabs,epsrel*dabs(reseps))
        if(abserr.le.ertest) go to 100
c
c            prepare bisection of the smallest interval.
c
   70   if(numrl2.eq.1) noext = .true.
        if(ier.eq.5) go to 100
        maxerr = iord(1)
        errmax = elist(maxerr)
        nrmax = 1
        extrap = .false.
        small = small*0.5d+00
        erlarg = errsum
        go to 90
   80   small = 0.375d+00
        erlarg = errsum
        ertest = errbnd
        rlist2(2) = area
   90 continue
c
c           set final result and error estimate.
c           ------------------------------------
c
  100 if(abserr.eq.oflow) go to 115
      if((ier+ierro).eq.0) go to 110
      if(ierro.eq.3) abserr = abserr+correc
      if(ier.eq.0) ier = 3
      if(result.ne.0.0d+00.and.area.ne.0.0d+00)go to 105
      if(abserr.gt.errsum)go to 115
      if(area.eq.0.0d+00) go to 130
      go to 110
  105 if(abserr/dabs(result).gt.errsum/dabs(area))go to 115
c
c           test on divergence
c
  110 if(ksgn.eq.(-1).and.dmax1(dabs(result),dabs(area)).le.
     * defabs*0.1d-01) go to 130
      if(0.1d-01.gt.(result/area).or.(result/area).gt.0.1d+03.
     *or.errsum.gt.dabs(area)) ier = 6
      go to 130
c
c           compute global integral sum.
c
  115 result = 0.0d+00
      do 120 k = 1,last
        result = result+rlist(k)
  120 continue
      abserr = errsum
  130 neval = 30*last-15
      if(inf.eq.2) neval = 2*neval
      if(ier.gt.2) ier=ier-1
  999 return
      end
      subroutine dqawoe (f,a,b,omega,integr,epsabs,epsrel,limit,icall,
     *  maxp1,result,abserr,neval,ier,last,alist,blist,rlist,elist,iord,
     *   nnlog,momcom,chebmo)
c***begin prologue  dqawoe
c***date written   800101   (yymmdd)
c***revision date  830518   (yymmdd)
c***category no.  h2a2a1
c***keywords  automatic integrator, special-purpose,
c             integrand with oscillatory cos or sin factor,
c             clenshaw-curtis method, (end point) singularities,
c             extrapolation, globally adaptive
c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
c***purpose  the routine calculates an approximation result to a given
c            definite integral
c            i = integral of f(x)*w(x) over (a,b)
c            where w(x) = cos(omega*x) or w(x)=sin(omega*x),
c            hopefully satisfying following claim for accuracy
c            abs(i-result).le.max(epsabs,epsrel*abs(i)).
c***description
c
c        computation of oscillatory integrals
c        standard fortran subroutine
c        double precision version
c
c        parameters
c         on entry
c            f      - double precision
c                     function subprogram defining the integrand
c                     function f(x). the actual name for f needs to be
c                     declared e x t e r n a l in the driver program.
c
c            a      - double precision
c                     lower limit of integration
c
c            b      - double precision
c                     upper limit of integration
c
c            omega  - double precision
c                     parameter in the integrand weight function
c
c            integr - integer
c                     indicates which of the weight functions is to be
c                     used
c                     integr = 1      w(x) = cos(omega*x)
c                     integr = 2      w(x) = sin(omega*x)
c                     if integr.ne.1 and integr.ne.2, the routine
c                     will end with ier = 6.
c
c            epsabs - double precision
c                     absolute accuracy requested
c            epsrel - double precision
c                     relative accuracy requested
c                     if  epsabs.le.0
c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
c                     the routine will end with ier = 6.
c
c            limit  - integer
c                     gives an upper bound on the number of subdivisions
c                     in the partition of (a,b), limit.ge.1.
c
c            icall  - integer
c                     if dqawoe is to be used only once, icall must
c                     be set to 1.  assume that during this call, the
c                     chebyshev moments (for clenshaw-curtis integration
c                     of degree 24) have been computed for intervals of
c                     lenghts (abs(b-a))*2**(-l), l=0,1,2,...momcom-1.
c                     if icall.gt.1 this means that dqawoe has been
c                     called twice or more on intervals of the same
c                     length abs(b-a). the chebyshev moments already
c                     computed are then re-used in subsequent calls.
c                     if icall.lt.1, the routine will end with ier = 6.
c
c            maxp1  - integer
c                     gives an upper bound on the number of chebyshev
c                     moments which can be stored, i.e. for the
c                     intervals of lenghts abs(b-a)*2**(-l),
c                     l=0,1, ..., maxp1-2, maxp1.ge.1.
c                     if maxp1.lt.1, the routine will end with ier = 6.
c
c         on return
c            result - double precision
c                     approximation to the integral
c
c            abserr - double precision
c                     estimate of the modulus of the absolute error,
c                     which should equal or exceed abs(i-result)
c
c            neval  - integer
c                     number of integrand evaluations
c
c            ier    - integer
c                     ier = 0 normal and reliable termination of the
c                             routine. it is assumed that the
c                             requested accuracy has been achieved.
c                   - ier.gt.0 abnormal termination of the routine.
c                             the estimates for integral and error are
c                             less reliable. it is assumed that the
c                             requested accuracy has not been achieved.
c            error messages
c                     ier = 1 maximum number of subdivisions allowed
c                             has been achieved. one can allow more
c                             subdivisions by increasing the value of
c                             limit (and taking according dimension
c                             adjustments into account). however, if
c                             this yields no improvement it is advised
c                             to analyze the integrand, in order to
c                             determine the integration difficulties.
c                             if the position of a local difficulty can
c                             be determined (e.g. singularity,
c                             discontinuity within the interval) one
c                             will probably gain from splitting up the
c                             interval at this point and calling the
c                             integrator on the subranges. if possible,
c                             an appropriate special-purpose integrator
c                             should be used which is designed for
c                             handling the type of difficulty involved.
c                         = 2 the occurrence of roundoff error is
c                             detected, which prevents the requested
c                             tolerance from being achieved.
c                             the error may be under-estimated.
c                         = 3 extremely bad integrand behaviour occurs
c                             at some points of the integration
c                             interval.
c                         = 4 the algorithm does not converge.
c                             roundoff error is detected in the
c                             extrapolation table.
c                             it is presumed that the requested
c                             tolerance cannot be achieved due to
c                             roundoff in the extrapolation table,
c                             and that the returned result is the
c                             best which can be obtained.
c                         = 5 the integral is probably divergent, or
c                             slowly convergent. it must be noted that
c                             divergence can occur with any other value
c                             of ier.gt.0.
c                         = 6 the input is invalid, because
c                             (epsabs.le.0 and
c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28))
c                             or (integr.ne.1 and integr.ne.2) or
c                             icall.lt.1 or maxp1.lt.1.
c                             result, abserr, neval, last, rlist(1),
c                             elist(1), iord(1) and nnlog(1) are set
c                             to zero. alist(1) and blist(1) are set
c                             to a and b respectively.
c
c            last  -  integer
c                     on return, last equals the number of
c                     subintervals produces in the subdivision
c                     process, which determines the number of
c                     significant elements actually in the
c                     work arrays.
c            alist  - double precision
c                     vector of dimension at least limit, the first
c                      last  elements of which are the left
c                     end points of the subintervals in the partition
c                     of the given integration range (a,b)
c
c            blist  - double precision
c                     vector of dimension at least limit, the first
c                      last  elements of which are the right
c                     end points of the subintervals in the partition
c                     of the given integration range (a,b)
c
c            rlist  - double precision
c                     vector of dimension at least limit, the first
c                      last  elements of which are the integral
c                     approximations on the subintervals
c
c            elist  - double precision
c                     vector of dimension at least limit, the first
c                      last  elements of which are the moduli of the
c                     absolute error estimates on the subintervals
c
c            iord   - integer
c                     vector of dimension at least limit, the first k
c                     elements of which are pointers to the error
c                     estimates over the subintervals,
c                     such that elist(iord(1)), ...,
c                     elist(iord(k)) form a decreasing sequence, with
c                     k = last if last.le.(limit/2+2), and
c                     k = limit+1-last otherwise.
c
c            nnlog  - integer
c                     vector of dimension at least limit, containing the
c                     subdivision levels of the subintervals, i.e.
c                     iwork(i) = l means that the subinterval
c                     numbered i is of length abs(b-a)*2**(1-l)
c
c         on entry and return
c            momcom - integer
c                     indicating that the chebyshev moments
c                     have been computed for intervals of lengths
c                     (abs(b-a))*2**(-l), l=0,1,2, ..., momcom-1,
c                     momcom.lt.maxp1
c
c            chebmo - double precision
c                     array of dimension (maxp1,25) containing the
c                     chebyshev moments
c
c***references  (none)
c***routines called  d1mach,dqc25f,dqelg,dqpsrt
c***end prologue  dqawoe
c
      double precision a,abseps,abserr,alist,area,area1,area12,area2,a1,
     *  a2,b,blist,b1,b2,chebmo,correc,dabs,defab1,defab2,defabs,dmax1,
     *  domega,d1mach,dres,elist,epmach,epsabs,epsrel,erlarg,erlast,
     *  errbnd,errmax,error1,erro12,error2,errsum,ertest,f,oflow,
     *  omega,resabs,reseps,result,res3la,rlist,rlist2,small,uflow,width
      integer icall,id,ier,ierro,integr,iord,iroff1,iroff2,iroff3,
     *  jupbnd,k,ksgn,ktmin,last,limit,maxerr,maxp1,momcom,nev,neval,
     *  nnlog,nres,nrmax,nrmom,numrl2
      logical extrap,noext,extall
c
      dimension alist(limit),blist(limit),rlist(limit),elist(limit),
     *  iord(limit),rlist2(52),res3la(3),chebmo(maxp1,25),nnlog(limit)
c
      external f
c
c            the dimension of rlist2 is determined by  the value of
c            limexp in subroutine dqelg (rlist2 should be of
c            dimension (limexp+2) at least).
c
c            list of major variables
c            -----------------------
c
c           alist     - list of left end points of all subintervals
c                       considered up to now
c           blist     - list of right end points of all subintervals
c                       considered up to now
c           rlist(i)  - approximation to the integral over
c                       (alist(i),blist(i))
c           rlist2    - array of dimension at least limexp+2
c                       containing the part of the epsilon table
c                       which is still needed for further computations
c           elist(i)  - error estimate applying to rlist(i)
c           maxerr    - pointer to the interval with largest
c                       error estimate
c           errmax    - elist(maxerr)
c           erlast    - error on the interval currently subdivided
c           area      - sum of the integrals over the subintervals
c           errsum    - sum of the errors over the subintervals
c           errbnd    - requested accuracy max(epsabs,epsrel*
c                       abs(result))
c           *****1    - variable for the left subinterval
c           *****2    - variable for the right subinterval
c           last      - index for subdivision
c           nres      - number of calls to the extrapolation routine
c           numrl2    - number of elements in rlist2. if an appropriate
c                       approximation to the compounded integral has
c                       been obtained it is put in rlist2(numrl2) after
c                       numrl2 has been increased by one
c           small     - length of the smallest interval considered
c                       up to now, multiplied by 1.5
c           erlarg    - sum of the errors over the intervals larger
c                       than the smallest interval considered up to now
c           extrap    - logical variable denoting that the routine is
c                       attempting to perform extrapolation, i.e. before
c                       subdividing the smallest interval we try to
c                       decrease the value of erlarg
c           noext     - logical variable denoting that extrapolation
c                       is no longer allowed (true  value)
c
c            machine dependent constants
c            ---------------------------
c
c           epmach is the largest relative spacing.
c           uflow is the smallest positive magnitude.
c           oflow is the largest positive magnitude.
c
c***first executable statement  dqawoe
      epmach = d1mach(4)
c
c         test on validity of parameters
c         ------------------------------
c
      ier = 0
      neval = 0
      last = 0
      result = 0.0d+00
      abserr = 0.0d+00
      alist(1) = a
      blist(1) = b
      rlist(1) = 0.0d+00
      elist(1) = 0.0d+00
      iord(1) = 0
      nnlog(1) = 0
      if((integr.ne.1.and.integr.ne.2).or.(epsabs.le.0.0d+00.and.
     *  epsrel.lt.dmax1(0.5d+02*epmach,0.5d-28)).or.icall.lt.1.or.
     *  maxp1.lt.1) ier = 6
      if(ier.eq.6) go to 999
c
c           first approximation to the integral
c           -----------------------------------
c
      domega = dabs(omega)
      nrmom = 0
      if (icall.gt.1) go to 5
      momcom = 0
    5 call dqc25f(f,a,b,domega,integr,nrmom,maxp1,0,result,abserr,
     *  neval,defabs,resabs,momcom,chebmo)
c
c           test on accuracy.
c
      dres = dabs(result)
      errbnd = dmax1(epsabs,epsrel*dres)
      rlist(1) = result
      elist(1) = abserr
      iord(1) = 1
      if(abserr.le.0.1d+03*epmach*defabs.and.abserr.gt.errbnd) ier = 2
      if(limit.eq.1) ier = 1
      if(ier.ne.0.or.abserr.le.errbnd) go to 200
c
c           initializations
c           ---------------
c
      uflow = d1mach(1)
      oflow = d1mach(2)
      errmax = abserr
      maxerr = 1
      area = result
      errsum = abserr
      abserr = oflow
      nrmax = 1
      extrap = .false.
      noext = .false.
      ierro = 0
      iroff1 = 0
      iroff2 = 0
      iroff3 = 0
      ktmin = 0
      small = dabs(b-a)*0.75d+00
      nres = 0
      numrl2 = 0
      extall = .false.
      if(0.5d+00*dabs(b-a)*domega.gt.0.2d+01) go to 10
      numrl2 = 1
      extall = .true.
      rlist2(1) = result
   10 if(0.25d+00*dabs(b-a)*domega.le.0.2d+01) extall = .true.
      ksgn = -1
      if(dres.ge.(0.1d+01-0.5d+02*epmach)*defabs) ksgn = 1
c
c           main do-loop
c           ------------
c
      do 140 last = 2,limit
c
c           bisect the subinterval with the nrmax-th largest
c           error estimate.
c
        nrmom = nnlog(maxerr)+1
        a1 = alist(maxerr)
        b1 = 0.5d+00*(alist(maxerr)+blist(maxerr))
        a2 = b1
        b2 = blist(maxerr)
        erlast = errmax
        call dqc25f(f,a1,b1,domega,integr,nrmom,maxp1,0,
     *  area1,error1,nev,resabs,defab1,momcom,chebmo)
        neval = neval+nev
        call dqc25f(f,a2,b2,domega,integr,nrmom,maxp1,1,
     *  area2,error2,nev,resabs,defab2,momcom,chebmo)
        neval = neval+nev
c
c           improve previous approximations to integral
c           and error and test for accuracy.
c
        area12 = area1+area2
        erro12 = error1+error2
        errsum = errsum+erro12-errmax
        area = area+area12-rlist(maxerr)
        if(defab1.eq.error1.or.defab2.eq.error2) go to 25
        if(dabs(rlist(maxerr)-area12).gt.0.1d-04*dabs(area12)
     *  .or.erro12.lt.0.99d+00*errmax) go to 20
        if(extrap) iroff2 = iroff2+1
        if(.not.extrap) iroff1 = iroff1+1
   20   if(last.gt.10.and.erro12.gt.errmax) iroff3 = iroff3+1
   25   rlist(maxerr) = area1
        rlist(last) = area2
        nnlog(maxerr) = nrmom
        nnlog(last) = nrmom
        errbnd = dmax1(epsabs,epsrel*dabs(area))
c
c           test for roundoff error and eventually set error flag.
c
        if(iroff1+iroff2.ge.10.or.iroff3.ge.20) ier = 2
        if(iroff2.ge.5) ierro = 3
c
c           set error flag in the case that the number of
c           subintervals equals limit.
c
        if(last.eq.limit) ier = 1
c
c           set error flag in the case of bad integrand behaviour
c           at a point of the integration range.
c
        if(dmax1(dabs(a1),dabs(b2)).le.(0.1d+01+0.1d+03*epmach)
     *  *(dabs(a2)+0.1d+04*uflow)) ier = 4
c
c           append the newly-created intervals to the list.
c
        if(error2.gt.error1) go to 30
        alist(last) = a2
        blist(maxerr) = b1
        blist(last) = b2
        elist(maxerr) = error1
        elist(last) = error2
        go to 40
   30   alist(maxerr) = a2
        alist(last) = a1
        blist(last) = b1
        rlist(maxerr) = area2
        rlist(last) = area1
        elist(maxerr) = error2
        elist(last) = error1
c
c           call subroutine dqpsrt to maintain the descending ordering
c           in the list of error estimates and select the subinterval
c           with nrmax-th largest error estimate (to bisected next).
c
   40   call dqpsrt(limit,last,maxerr,errmax,elist,iord,nrmax)
c ***jump out of do-loop
      if(errsum.le.errbnd) go to 170
      if(ier.ne.0) go to 150
        if(last.eq.2.and.extall) go to 120
        if(noext) go to 140
        if(.not.extall) go to 50
        erlarg = erlarg-erlast
        if(dabs(b1-a1).gt.small) erlarg = erlarg+erro12
        if(extrap) go to 70
c
c           test whether the interval to be bisected next is the
c           smallest interval.
c
   50   width = dabs(blist(maxerr)-alist(maxerr))
        if(width.gt.small) go to 140
        if(extall) go to 60
c
c           test whether we can start with the extrapolation procedure
c           (we do this if we integrate over the next interval with
c           use of a gauss-kronrod rule - see subroutine dqc25f).
c
        small = small*0.5d+00
        if(0.25d+00*width*domega.gt.0.2d+01) go to 140
        extall = .true.
        go to 130
   60   extrap = .true.
        nrmax = 2
   70   if(ierro.eq.3.or.erlarg.le.ertest) go to 90
c
c           the smallest interval has the largest error.
c           before bisecting decrease the sum of the errors over
c           the larger intervals (erlarg) and perform extrapolation.
c
        jupbnd = last
        if (last.gt.(limit/2+2)) jupbnd = limit+3-last
        id = nrmax
        do 80 k = id,jupbnd
          maxerr = iord(nrmax)
          errmax = elist(maxerr)
          if(dabs(blist(maxerr)-alist(maxerr)).gt.small) go to 140
          nrmax = nrmax+1
   80   continue
c
c           perform extrapolation.
c
   90   numrl2 = numrl2+1
        rlist2(numrl2) = area
        if(numrl2.lt.3) go to 110
        call dqelg(numrl2,rlist2,reseps,abseps,res3la,nres)
        ktmin = ktmin+1
        if(ktmin.gt.5.and.abserr.lt.0.1d-02*errsum) ier = 5
        if(abseps.ge.abserr) go to 100
        ktmin = 0
        abserr = abseps
        result = reseps
        correc = erlarg
        ertest = dmax1(epsabs,epsrel*dabs(reseps))
c ***jump out of do-loop
        if(abserr.le.ertest) go to 150
c
c           prepare bisection of the smallest interval.
c
  100   if(numrl2.eq.1) noext = .true.
        if(ier.eq.5) go to 150
  110   maxerr = iord(1)
        errmax = elist(maxerr)
        nrmax = 1
        extrap = .false.
        small = small*0.5d+00
        erlarg = errsum
        go to 140
  120   small = small*0.5d+00
        numrl2 = numrl2+1
        rlist2(numrl2) = area
  130   ertest = errbnd
        erlarg = errsum
  140 continue
c
c           set the final result.
c           ---------------------
c
  150 if(abserr.eq.oflow.or.nres.eq.0) go to 170
      if(ier+ierro.eq.0) go to 165
      if(ierro.eq.3) abserr = abserr+correc
      if(ier.eq.0) ier = 3
      if(result.ne.0.0d+00.and.area.ne.0.0d+00) go to 160
      if(abserr.gt.errsum) go to 170
      if(area.eq.0.0d+00) go to 190
      go to 165
  160 if(abserr/dabs(result).gt.errsum/dabs(area)) go to 170
c
c           test on divergence.
c
  165 if(ksgn.eq.(-1).and.dmax1(dabs(result),dabs(area)).le.
     * defabs*0.1d-01) go to 190
      if(0.1d-01.gt.(result/area).or.(result/area).gt.0.1d+03
     * .or.errsum.ge.dabs(area)) ier = 6
      go to 190
c
c           compute global integral sum.
c
  170 result = 0.0d+00
      do 180 k=1,last
        result = result+rlist(k)
  180 continue
      abserr = errsum
  190 if (ier.gt.2) ier=ier-1
  200 if (integr.eq.2.and.omega.lt.0.0d+00) result=-result
  999 return
      end
      subroutine dqc25f(f,a,b,omega,integr,nrmom,maxp1,ksave,result,
     *   abserr,neval,resabs,resasc,momcom,chebmo)
c***begin prologue  dqc25f
c***date written   810101   (yymmdd)
c***revision date  830518   (yymmdd)
c***category no.  h2a2a2
c***keywords  integration rules for functions with cos or sin
c             factor, clenshaw-curtis, gauss-kronrod
c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
c***purpose  to compute the integral i=integral of f(x) over (a,b)
c            where w(x) = cos(omega*x) or w(x)=sin(omega*x) and to
c            compute j = integral of abs(f) over (a,b). for small value
c            of omega or small intervals (a,b) the 15-point gauss-kronro
c            rule is used. otherwise a generalized clenshaw-curtis
c            method is used.
c***description
c
c        integration rules for functions with cos or sin factor
c        standard fortran subroutine
c        double precision version
c
c        parameters
c         on entry
c           f      - double precision
c                    function subprogram defining the integrand
c                    function f(x). the actual name for f needs to
c                    be declared e x t e r n a l in the calling program.
c
c           a      - double precision
c                    lower limit of integration
c
c           b      - double precision
c                    upper limit of integration
c
c           omega  - double precision
c                    parameter in the weight function
c
c           integr - integer
c                    indicates which weight function is to be used
c                       integr = 1   w(x) = cos(omega*x)
c                       integr = 2   w(x) = sin(omega*x)
c
c           nrmom  - integer
c                    the length of interval (a,b) is equal to the length
c                    of the original integration interval divided by
c                    2**nrmom (we suppose that the routine is used in an
c                    adaptive integration process, otherwise set
c                    nrmom = 0). nrmom must be zero at the first call.
c
c           maxp1  - integer
c                    gives an upper bound on the number of chebyshev
c                    moments which can be stored, i.e. for the
c                    intervals of lengths abs(bb-aa)*2**(-l),
c                    l = 0,1,2, ..., maxp1-2.
c
c           ksave  - integer
c                    key which is one when the moments for the
c                    current interval have been computed
c
c         on return
c           result - double precision
c                    approximation to the integral i
c
c           abserr - double precision
c                    estimate of the modulus of the absolute
c                    error, which should equal or exceed abs(i-result)
c
c           neval  - integer
c                    number of integrand evaluations
c
c           resabs - double precision
c                    approximation to the integral j
c
c           resasc - double precision
c                    approximation to the integral of abs(f-i/(b-a))
c
c         on entry and return
c           momcom - integer
c                    for each interval length we need to compute the
c                    chebyshev moments. momcom counts the number of
c                    intervals for which these moments have already been
c                    computed. if nrmom.lt.momcom or ksave = 1, the
c                    chebyshev moments for the interval (a,b) have
c                    already been computed and stored, otherwise we
c                    compute them and we increase momcom.
c
c           chebmo - double precision
c                    array of dimension at least (maxp1,25) containing
c                    the modified chebyshev moments for the first momcom
c                    momcom interval lengths
c
c ......................................................................
c***references  (none)
c***routines called  d1mach,dgtsl,dqcheb,dqk15w,dqwgtf
c***end prologue  dqc25f
c
      double precision a,abserr,ac,an,an2,as,asap,ass,b,centr,chebmo,
     *  cheb12,cheb24,conc,cons,cospar,d,dabs,dcos,dsin,dqwgtf,d1,
     *  d1mach,d2,estc,ests,f,fval,hlgth,oflow,omega,parint,par2,par22,
     *  p2,p3,p4,resabs,resasc,resc12,resc24,ress12,ress24,result,
     *  sinpar,v,x
      integer i,iers,integr,isym,j,k,ksave,m,momcom,neval,maxp1,
     *  noequ,noeq1,nrmom
c
      dimension chebmo(maxp1,25),cheb12(13),cheb24(25),d(25),d1(25),
     *  d2(25),fval(25),v(28),x(11)
c
      external f,dqwgtf
c
c           the vector x contains the values cos(k*pi/24)
c           k = 1, ...,11, to be used for the chebyshev expansion of f
c
      data x(1) / 0.9914448613 7381041114 4557526928 563d0 /
      data x(2) / 0.9659258262 8906828674 9743199728 897d0 /
      data x(3) / 0.9238795325 1128675612 8183189396 788d0 /
      data x(4) / 0.8660254037 8443864676 3723170752 936d0 /
      data x(5) / 0.7933533402 9123516457 9776961501 299d0 /
      data x(6) / 0.7071067811 8654752440 0844362104 849d0 /
      data x(7) / 0.6087614290 0872063941 6097542898 164d0 /
      data x(8) / 0.5000000000 0000000000 0000000000 000d0 /
      data x(9) / 0.3826834323 6508977172 8459984030 399d0 /
      data x(10) / 0.2588190451 0252076234 8898837624 048d0 /
      data x(11) / 0.1305261922 2005159154 8406227895 489d0 /
c
c           list of major variables
c           -----------------------
c
c           centr  - mid point of the integration interval
c           hlgth  - half-length of the integration interval
c           fval   - value of the function f at the points
c                    (b-a)*0.5*cos(k*pi/12) + (b+a)*0.5, k = 0, ..., 24
c           cheb12 - coefficients of the chebyshev series expansion
c                    of degree 12, for the function f, in the
c                    interval (a,b)
c           cheb24 - coefficients of the chebyshev series expansion
c                    of degree 24, for the function f, in the
c                    interval (a,b)
c           resc12 - approximation to the integral of
c                    cos(0.5*(b-a)*omega*x)*f(0.5*(b-a)*x+0.5*(b+a))
c                    over (-1,+1), using the chebyshev series
c                    expansion of degree 12
c           resc24 - approximation to the same integral, using the
c                    chebyshev series expansion of degree 24
c           ress12 - the analogue of resc12 for the sine
c           ress24 - the analogue of resc24 for the sine
c
c
c           machine dependent constant
c           --------------------------
c
c           oflow is the largest positive magnitude.
c
c***first executable statement  dqc25f
      oflow = d1mach(2)
c
      centr = 0.5d+00*(b+a)
      hlgth = 0.5d+00*(b-a)
      parint = omega*hlgth
c
c           compute the integral using the 15-point gauss-kronrod
c           formula if the value of the parameter in the integrand
c           is small.
c
      if(dabs(parint).gt.0.2d+01) go to 10
      call dqk15w(f,dqwgtf,omega,p2,p3,p4,integr,a,b,result,
     *  abserr,resabs,resasc)
      neval = 15
      go to 170
c
c           compute the integral using the generalized clenshaw-
c           curtis method.
c
   10 conc = hlgth*dcos(centr*omega)
      cons = hlgth*dsin(centr*omega)
      resasc = oflow
      neval = 25
c
c           check whether the chebyshev moments for this interval
c           have already been computed.
c
      if(nrmom.lt.momcom.or.ksave.eq.1) go to 120
c
c           compute a new set of chebyshev moments.
c
      m = momcom+1
      par2 = parint*parint
      par22 = par2+0.2d+01
      sinpar = dsin(parint)
      cospar = dcos(parint)
c
c           compute the chebyshev moments with respect to cosine.
c
      v(1) = 0.2d+01*sinpar/parint
      v(2) = (0.8d+01*cospar+(par2+par2-0.8d+01)*sinpar/parint)/par2
      v(3) = (0.32d+02*(par2-0.12d+02)*cospar+(0.2d+01*
     *  ((par2-0.80d+02)*par2+0.192d+03)*sinpar)/parint)/(par2*par2)
      ac = 0.8d+01*cospar
      as = 0.24d+02*parint*sinpar
      if(dabs(parint).gt.0.24d+02) go to 30
c
c           compute the chebyshev moments as the solutions of a
c           boundary value problem with 1 initial value (v(3)) and 1
c           end value (computed using an asymptotic formula).
c
      noequ = 25
      noeq1 = noequ-1
      an = 0.6d+01
      do 20 k = 1,noeq1
        an2 = an*an
        d(k) = -0.2d+01*(an2-0.4d+01)*(par22-an2-an2)
        d2(k) = (an-0.1d+01)*(an-0.2d+01)*par2
        d1(k+1) = (an+0.3d+01)*(an+0.4d+01)*par2
        v(k+3) = as-(an2-0.4d+01)*ac
        an = an+0.2d+01
   20 continue
      an2 = an*an
      d(noequ) = -0.2d+01*(an2-0.4d+01)*(par22-an2-an2)
      v(noequ+3) = as-(an2-0.4d+01)*ac
      v(4) = v(4)-0.56d+02*par2*v(3)
      ass = parint*sinpar
      asap = (((((0.210d+03*par2-0.1d+01)*cospar-(0.105d+03*par2
     *  -0.63d+02)*ass)/an2-(0.1d+01-0.15d+02*par2)*cospar
     *  +0.15d+02*ass)/an2-cospar+0.3d+01*ass)/an2-cospar)/an2
      v(noequ+3) = v(noequ+3)-0.2d+01*asap*par2*(an-0.1d+01)*
     *   (an-0.2d+01)
c
c           solve the tridiagonal system by means of gaussian
c           elimination with partial pivoting.
c
c***        call to dgtsl must be replaced by call to
c***        double precision version of linpack routine sgtsl
c
c$$$      call dgtsl(noequ,d1,d,d2,v(4),iers)
      go to 50
c
c           compute the chebyshev moments by means of forward
c           recursion.
c
   30 an = 0.4d+01
      do 40 i = 4,13
        an2 = an*an
        v(i) = ((an2-0.4d+01)*(0.2d+01*(par22-an2-an2)*v(i-1)-ac)
     *  +as-par2*(an+0.1d+01)*(an+0.2d+01)*v(i-2))/
     *  (par2*(an-0.1d+01)*(an-0.2d+01))
        an = an+0.2d+01
   40 continue
   50 do 60 j = 1,13
        chebmo(m,2*j-1) = v(j)
   60 continue
c
c           compute the chebyshev moments with respect to sine.
c
      v(1) = 0.2d+01*(sinpar-parint*cospar)/par2
      v(2) = (0.18d+02-0.48d+02/par2)*sinpar/par2
     *  +(-0.2d+01+0.48d+02/par2)*cospar/parint
      ac = -0.24d+02*parint*cospar
      as = -0.8d+01*sinpar
      if(dabs(parint).gt.0.24d+02) go to 80
c
c           compute the chebyshev moments as the solutions of a boundary
c           value problem with 1 initial value (v(2)) and 1 end value
c           (computed using an asymptotic formula).
c
      an = 0.5d+01
      do 70 k = 1,noeq1
        an2 = an*an
        d(k) = -0.2d+01*(an2-0.4d+01)*(par22-an2-an2)
        d2(k) = (an-0.1d+01)*(an-0.2d+01)*par2
        d1(k+1) = (an+0.3d+01)*(an+0.4d+01)*par2
        v(k+2) = ac+(an2-0.4d+01)*as
        an = an+0.2d+01
   70 continue
      an2 = an*an
      d(noequ) = -0.2d+01*(an2-0.4d+01)*(par22-an2-an2)
      v(noequ+2) = ac+(an2-0.4d+01)*as
      v(3) = v(3)-0.42d+02*par2*v(2)
      ass = parint*cospar
      asap = (((((0.105d+03*par2-0.63d+02)*ass+(0.210d+03*par2
     *  -0.1d+01)*sinpar)/an2+(0.15d+02*par2-0.1d+01)*sinpar-
     *  0.15d+02*ass)/an2-0.3d+01*ass-sinpar)/an2-sinpar)/an2
      v(noequ+2) = v(noequ+2)-0.2d+01*asap*par2*(an-0.1d+01)
     *  *(an-0.2d+01)
c
c           solve the tridiagonal system by means of gaussian
c           elimination with partial pivoting.
c
c***        call to dgtsl must be replaced by call to
c***        double precision version of linpack routine sgtsl
c
c$$$      call dgtsl(noequ,d1,d,d2,v(3),iers)
      go to 100
c
c           compute the chebyshev moments by means of forward recursion.
c
   80 an = 0.3d+01
      do 90 i = 3,12
        an2 = an*an
        v(i) = ((an2-0.4d+01)*(0.2d+01*(par22-an2-an2)*v(i-1)+as)
     *  +ac-par2*(an+0.1d+01)*(an+0.2d+01)*v(i-2))
     *  /(par2*(an-0.1d+01)*(an-0.2d+01))
        an = an+0.2d+01
   90 continue
  100 do 110 j = 1,12
        chebmo(m,2*j) = v(j)
  110 continue
  120 if (nrmom.lt.momcom) m = nrmom+1
       if (momcom.lt.(maxp1-1).and.nrmom.ge.momcom) momcom = momcom+1
c
c           compute the coefficients of the chebyshev expansions
c           of degrees 12 and 24 of the function f.
c
      fval(1) = 0.5d+00*f(centr+hlgth)
      fval(13) = f(centr)
      fval(25) = 0.5d+00*f(centr-hlgth)
      do 130 i = 2,12
        isym = 26-i
        fval(i) = f(hlgth*x(i-1)+centr)
        fval(isym) = f(centr-hlgth*x(i-1))
  130 continue
      call dqcheb(x,fval,cheb12,cheb24)
c
c           compute the integral and error estimates.
c
      resc12 = cheb12(13)*chebmo(m,13)
      ress12 = 0.0d+00
      k = 11
      do 140 j = 1,6
        resc12 = resc12+cheb12(k)*chebmo(m,k)
        ress12 = ress12+cheb12(k+1)*chebmo(m,k+1)
        k = k-2
  140 continue
      resc24 = cheb24(25)*chebmo(m,25)
      ress24 = 0.0d+00
      resabs = dabs(cheb24(25))
      k = 23
      do 150 j = 1,12
        resc24 = resc24+cheb24(k)*chebmo(m,k)
        ress24 = ress24+cheb24(k+1)*chebmo(m,k+1)
        resabs = dabs(cheb24(k))+dabs(cheb24(k+1))
        k = k-2
  150 continue
      estc = dabs(resc24-resc12)
      ests = dabs(ress24-ress12)
      resabs = resabs*dabs(hlgth)
      if(integr.eq.2) go to 160
      result = conc*resc24-cons*ress24
      abserr = dabs(conc*estc)+dabs(cons*ests)
      go to 170
  160 result = conc*ress24+cons*resc24
      abserr = dabs(conc*ests)+dabs(cons*estc)
  170 return
      end
      subroutine dqcheb(x,fval,cheb12,cheb24)
c***begin prologue  dqcheb
c***refer to  dqc25c,dqc25f,dqc25s
c***routines called  (none)
c***revision date  830518   (yymmdd)
c***keywords  chebyshev series expansion, fast fourier transform
c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
c***purpose  this routine computes the chebyshev series expansion
c            of degrees 12 and 24 of a function using a
c            fast fourier transform method
c            f(x) = sum(k=1,..,13) (cheb12(k)*t(k-1,x)),
c            f(x) = sum(k=1,..,25) (cheb24(k)*t(k-1,x)),
c            where t(k,x) is the chebyshev polynomial of degree k.
c***description
c
c        chebyshev series expansion
c        standard fortran subroutine
c        double precision version
c
c        parameters
c          on entry
c           x      - double precision
c                    vector of dimension 11 containing the
c                    values cos(k*pi/24), k = 1, ..., 11
c
c           fval   - double precision
c                    vector of dimension 25 containing the
c                    function values at the points
c                    (b+a+(b-a)*cos(k*pi/24))/2, k = 0, ...,24,
c                    where (a,b) is the approximation interval.
c                    fval(1) and fval(25) are divided by two
c                    (these values are destroyed at output).
c
c          on return
c           cheb12 - double precision
c                    vector of dimension 13 containing the
c                    chebyshev coefficients for degree 12
c
c           cheb24 - double precision
c                    vector of dimension 25 containing the
c                    chebyshev coefficients for degree 24
c
c***end prologue  dqcheb
c
      double precision alam,alam1,alam2,cheb12,cheb24,fval,part1,part2,
     *  part3,v,x
      integer i,j
c
      dimension cheb12(13),cheb24(25),fval(25),v(12),x(11)
c
c***first executable statement  dqcheb
      do 10 i=1,12
        j = 26-i
        v(i) = fval(i)-fval(j)
        fval(i) = fval(i)+fval(j)
   10 continue
      alam1 = v(1)-v(9)
      alam2 = x(6)*(v(3)-v(7)-v(11))
      cheb12(4) = alam1+alam2
      cheb12(10) = alam1-alam2
      alam1 = v(2)-v(8)-v(10)
      alam2 = v(4)-v(6)-v(12)
      alam = x(3)*alam1+x(9)*alam2
      cheb24(4) = cheb12(4)+alam
      cheb24(22) = cheb12(4)-alam
      alam = x(9)*alam1-x(3)*alam2
      cheb24(10) = cheb12(10)+alam
      cheb24(16) = cheb12(10)-alam
      part1 = x(4)*v(5)
      part2 = x(8)*v(9)
      part3 = x(6)*v(7)
      alam1 = v(1)+part1+part2
      alam2 = x(2)*v(3)+part3+x(10)*v(11)
      cheb12(2) = alam1+alam2
      cheb12(12) = alam1-alam2
      alam = x(1)*v(2)+x(3)*v(4)+x(5)*v(6)+x(7)*v(8)
     *  +x(9)*v(10)+x(11)*v(12)
      cheb24(2) = cheb12(2)+alam
      cheb24(24) = cheb12(2)-alam
      alam = x(11)*v(2)-x(9)*v(4)+x(7)*v(6)-x(5)*v(8)
     *  +x(3)*v(10)-x(1)*v(12)
      cheb24(12) = cheb12(12)+alam
      cheb24(14) = cheb12(12)-alam
      alam1 = v(1)-part1+part2
      alam2 = x(10)*v(3)-part3+x(2)*v(11)
      cheb12(6) = alam1+alam2
      cheb12(8) = alam1-alam2
      alam = x(5)*v(2)-x(9)*v(4)-x(1)*v(6)
     *  -x(11)*v(8)+x(3)*v(10)+x(7)*v(12)
      cheb24(6) = cheb12(6)+alam
      cheb24(20) = cheb12(6)-alam
      alam = x(7)*v(2)-x(3)*v(4)-x(11)*v(6)+x(1)*v(8)
     *  -x(9)*v(10)-x(5)*v(12)
      cheb24(8) = cheb12(8)+alam
      cheb24(18) = cheb12(8)-alam
      do 20 i=1,6
        j = 14-i
        v(i) = fval(i)-fval(j)
        fval(i) = fval(i)+fval(j)
   20 continue
      alam1 = v(1)+x(8)*v(5)
      alam2 = x(4)*v(3)
      cheb12(3) = alam1+alam2
      cheb12(11) = alam1-alam2
      cheb12(7) = v(1)-v(5)
      alam = x(2)*v(2)+x(6)*v(4)+x(10)*v(6)
      cheb24(3) = cheb12(3)+alam
      cheb24(23) = cheb12(3)-alam
      alam = x(6)*(v(2)-v(4)-v(6))
      cheb24(7) = cheb12(7)+alam
      cheb24(19) = cheb12(7)-alam
      alam = x(10)*v(2)-x(6)*v(4)+x(2)*v(6)
      cheb24(11) = cheb12(11)+alam
      cheb24(15) = cheb12(11)-alam
      do 30 i=1,3
        j = 8-i
        v(i) = fval(i)-fval(j)
        fval(i) = fval(i)+fval(j)
   30 continue
      cheb12(5) = v(1)+x(8)*v(3)
      cheb12(9) = fval(1)-x(8)*fval(3)
      alam = x(4)*v(2)
      cheb24(5) = cheb12(5)+alam
      cheb24(21) = cheb12(5)-alam
      alam = x(8)*fval(2)-fval(4)
      cheb24(9) = cheb12(9)+alam
      cheb24(17) = cheb12(9)-alam
      cheb12(1) = fval(1)+fval(3)
      alam = fval(2)+fval(4)
      cheb24(1) = cheb12(1)+alam
      cheb24(25) = cheb12(1)-alam
      cheb12(13) = v(1)-v(3)
      cheb24(13) = cheb12(13)
      alam = 0.1d+01/0.6d+01
      do 40 i=2,12
        cheb12(i) = cheb12(i)*alam
   40 continue
      alam = 0.5d+00*alam
      cheb12(1) = cheb12(1)*alam
      cheb12(13) = cheb12(13)*alam
      do 50 i=2,24
        cheb24(i) = cheb24(i)*alam
   50 continue
      cheb24(1) = 0.5d+00*alam*cheb24(1)
      cheb24(25) = 0.5d+00*alam*cheb24(25)
      return
      end
      subroutine dqk15i1(f,boun,inf,a,b,result,abserr,resabs,resasc)
c***begin prologue  dqk15i1
c***date written   800101   (yymmdd)
c***revision date  830518   (yymmdd)
c***category no.  h2a3a2,h2a4a2
c***keywords  15-point transformed gauss-kronrod rules
c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
c***purpose  the original (infinite integration range is mapped
c            onto the interval (0,1) and (a,b) is a part of (0,1).
c            it is the purpose to compute
c            i = integral of transformed integrand over (a,b),
c            j = integral of abs(transformed integrand) over (a,b).
c***description
c
c           integration rule
c           standard fortran subroutine
c           double precision version
c
c           parameters
c            on entry
c              f      - double precision
c                       fuction subprogram defining the integrand
c                       function f(x). the actual name for f needs to be
c                       declared e x t e r n a l in the calling program.
c
c              boun   - double precision
c                       finite bound of original integration
c                       range (set to zero if inf = +2)
c
c              inf    - integer
c                       if inf = -1, the original interval is
c                                   (-infinity,bound),
c                       if inf = +1, the original interval is
c                                   (bound,+infinity),
c                       if inf = +2, the original interval is
c                                   (-infinity,+infinity) and
c                       the integral is computed as the sum of two
c                       integrals, one over (-infinity,0) and one over
c                       (0,+infinity).
c
c              a      - double precision
c                       lower limit for integration over subrange
c                       of (0,1)
c
c              b      - double precision
c                       upper limit for integration over subrange
c                       of (0,1)
c
c            on return
c              result - double precision
c                       approximation to the integral i
c                       result is computed by applying the 15-point
c                       kronrod rule(resk) obtained by optimal addition
c                       of abscissae to the 7-point gauss rule(resg).
c
c              abserr - double precision
c                       estimate of the modulus of the absolute error,
c                       which should equal or exceed abs(i-result)
c
c              resabs - double precision
c                       approximation to the integral j
c
c              resasc - double precision
c                       approximation to the integral of
c                       abs((transformed integrand)-i/(b-a)) over (a,b)
c
c***references  (none)
c***routines called  d1mach
c***end prologue  dqk15i1
c
      double precision a,absc,absc1,absc2,abserr,b,boun,centr,dabs,dinf,
     *  dmax1,dmin1,d1mach,epmach,f,fc,fsum,fval1,fval2,fv1,fv2,hlgth,
     *  resabs,resasc,resg,resk,reskh,result,tabsc1,tabsc2,uflow,wg,wgk,
     *  xgk
      integer inf,j
      external f
c
      dimension fv1(7),fv2(7),xgk(8),wgk(8),wg(8)
c
c           the abscissae and weights are supplied for the interval
c           (-1,1).  because of symmetry only the positive abscissae and
c           their corresponding weights are given.
c
c           xgk    - abscissae of the 15-point kronrod rule
c                    xgk(2), xgk(4), ... abscissae of the 7-point
c                    gauss rule
c                    xgk(1), xgk(3), ...  abscissae which are optimally
c                    added to the 7-point gauss rule
c
c           wgk    - weights of the 15-point kronrod rule
c
c           wg     - weights of the 7-point gauss rule, corresponding
c                    to the abscissae xgk(2), xgk(4), ...
c                    wg(1), wg(3), ... are set to zero.
c
      data wg(1) / 0.0d0 /
      data wg(2) / 0.1294849661 6886969327 0611432679 082d0 /
      data wg(3) / 0.0d0 /
      data wg(4) / 0.2797053914 8927666790 1467771423 780d0 /
      data wg(5) / 0.0d0 /
      data wg(6) / 0.3818300505 0511894495 0369775488 975d0 /
      data wg(7) / 0.0d0 /
      data wg(8) / 0.4179591836 7346938775 5102040816 327d0 /
c
      data xgk(1) / 0.9914553711 2081263920 6854697526 329d0 /
      data xgk(2) / 0.9491079123 4275852452 6189684047 851d0 /
      data xgk(3) / 0.8648644233 5976907278 9712788640 926d0 /
      data xgk(4) / 0.7415311855 9939443986 3864773280 788d0 /
      data xgk(5) / 0.5860872354 6769113029 4144838258 730d0 /
      data xgk(6) / 0.4058451513 7739716690 6606412076 961d0 /
      data xgk(7) / 0.2077849550 0789846760 0689403773 245d0 /
      data xgk(8) / 0.0000000000 0000000000 0000000000 000d0 /
c
      data wgk(1) / 0.0229353220 1052922496 3732008058 970d0 /
      data wgk(2) / 0.0630920926 2997855329 0700663189 204d0 /
      data wgk(3) / 0.1047900103 2225018383 9876322541 518d0 /
      data wgk(4) / 0.1406532597 1552591874 5189590510 238d0 /
      data wgk(5) / 0.1690047266 3926790282 6583426598 550d0 /
      data wgk(6) / 0.1903505780 6478540991 3256402421 014d0 /
      data wgk(7) / 0.2044329400 7529889241 4161999234 649d0 /
      data wgk(8) / 0.2094821410 8472782801 2999174891 714d0 /
c
c
c           list of major variables
c           -----------------------
c
c           centr  - mid point of the interval
c           hlgth  - half-length of the interval
c           absc*  - abscissa
c           tabsc* - transformed abscissa
c           fval*  - function value
c           resg   - result of the 7-point gauss formula
c           resk   - result of the 15-point kronrod formula
c           reskh  - approximation to the mean value of the transformed
c                    integrand over (a,b), i.e. to i/(b-a)
c
c           machine dependent constants
c           ---------------------------
c
c           epmach is the largest relative spacing.
c           uflow is the smallest positive magnitude.
c
c***first executable statement  dqk15i1
      epmach = d1mach(4)
      uflow = d1mach(1)
      dinf = min0(1,inf)
c
      centr = 0.5d+00*(a+b)
      hlgth = 0.5d+00*(b-a)
      tabsc1 = boun+dinf*(0.1d+01-centr)/centr
      fval1 = f(tabsc1)
      if(inf.eq.2) fval1 = fval1+f(-tabsc1)
      fc = (fval1/centr)/centr
c
c           compute the 15-point kronrod approximation to
c           the integral, and estimate the error.
c
      resg = wg(8)*fc
      resk = wgk(8)*fc
      resabs = dabs(resk)
      do 10 j=1,7
        absc = hlgth*xgk(j)
        absc1 = centr-absc
        absc2 = centr+absc
        tabsc1 = boun+dinf*(0.1d+01-absc1)/absc1
        tabsc2 = boun+dinf*(0.1d+01-absc2)/absc2
        fval1 = f(tabsc1)
        fval2 = f(tabsc2)
        if(inf.eq.2) fval1 = fval1+f(-tabsc1)
        if(inf.eq.2) fval2 = fval2+f(-tabsc2)
        fval1 = (fval1/absc1)/absc1
        fval2 = (fval2/absc2)/absc2
        fv1(j) = fval1
        fv2(j) = fval2
        fsum = fval1+fval2
        resg = resg+wg(j)*fsum
        resk = resk+wgk(j)*fsum
        resabs = resabs+wgk(j)*(dabs(fval1)+dabs(fval2))
   10 continue
      reskh = resk*0.5d+00
      resasc = wgk(8)*dabs(fc-reskh)
      do 20 j=1,7
        resasc = resasc+wgk(j)*(dabs(fv1(j)-reskh)+dabs(fv2(j)-reskh))
   20 continue
      result = resk*hlgth
      resasc = resasc*hlgth
      resabs = resabs*hlgth
      abserr = dabs((resk-resg)*hlgth)
      if(resasc.ne.0.0d+00.and.abserr.ne.0.d0) abserr = resasc*
     * dmin1(0.1d+01,(0.2d+03*abserr/resasc)**1.5d+00)
      if(resabs.gt.uflow/(0.5d+02*epmach)) abserr = dmax1
     * ((epmach*0.5d+02)*resabs,abserr)
      return
      end
      subroutine dqk15w(f,w,p1,p2,p3,p4,kp,a,b,result,abserr,
     *   resabs,resasc)
c***begin prologue  dqk15w
c***date written   810101   (yymmdd)
c***revision date  830518   (mmddyy)
c***category no.  h2a2a2
c***keywords  15-point gauss-kronrod rules
c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
c***purpose  to compute i = integral of f*w over (a,b), with error
c                           estimate
c                       j = integral of abs(f*w) over (a,b)
c***description
c
c           integration rules
c           standard fortran subroutine
c           double precision version
c
c           parameters
c             on entry
c              f      - double precision
c                       function subprogram defining the integrand
c                       function f(x). the actual name for f needs to be
c                       declared e x t e r n a l in the driver program.
c
c              w      - double precision
c                       function subprogram defining the integrand
c                       weight function w(x). the actual name for w
c                       needs to be declared e x t e r n a l in the
c                       calling program.
c
c              p1, p2, p3, p4 - double precision
c                       parameters in the weight function
c
c              kp     - integer
c                       key for indicating the type of weight function
c
c              a      - double precision
c                       lower limit of integration
c
c              b      - double precision
c                       upper limit of integration
c
c            on return
c              result - double precision
c                       approximation to the integral i
c                       result is computed by applying the 15-point
c                       kronrod rule (resk) obtained by optimal addition
c                       of abscissae to the 7-point gauss rule (resg).
c
c              abserr - double precision
c                       estimate of the modulus of the absolute error,
c                       which should equal or exceed abs(i-result)
c
c              resabs - double precision
c                       approximation to the integral of abs(f)
c
c              resasc - double precision
c                       approximation to the integral of abs(f-i/(b-a))
c
c
c***references  (none)
c***routines called  d1mach
c***end prologue  dqk15w
c
      double precision a,absc,absc1,absc2,abserr,b,centr,dabs,dhlgth,
     *  dmax1,dmin1,d1mach,epmach,f,fc,fsum,fval1,fval2,fv1,fv2,hlgth,
     *  p1,p2,p3,p4,resabs,resasc,resg,resk,reskh,result,uflow,w,wg,wgk,
     *  xgk
      integer j,jtw,jtwm1,kp
      external f,w
c
      dimension fv1(7),fv2(7),xgk(8),wgk(8),wg(4)
c
c           the abscissae and weights are given for the interval (-1,1).
c           because of symmetry only the positive abscissae and their
c           corresponding weights are given.
c
c           xgk    - abscissae of the 15-point gauss-kronrod rule
c                    xgk(2), xgk(4), ... abscissae of the 7-point
c                    gauss rule
c                    xgk(1), xgk(3), ... abscissae which are optimally
c                    added to the 7-point gauss rule
c
c           wgk    - weights of the 15-point gauss-kronrod rule
c
c           wg     - weights of the 7-point gauss rule
c
      data xgk(1),xgk(2),xgk(3),xgk(4),xgk(5),xgk(6),xgk(7),xgk(8)/
     *     0.9914553711208126d+00,     0.9491079123427585d+00,
     *     0.8648644233597691d+00,     0.7415311855993944d+00,
     *     0.5860872354676911d+00,     0.4058451513773972d+00,
     *     0.2077849550078985d+00,     0.0000000000000000d+00/
c
      data wgk(1),wgk(2),wgk(3),wgk(4),wgk(5),wgk(6),wgk(7),wgk(8)/
     *     0.2293532201052922d-01,     0.6309209262997855d-01,
     *     0.1047900103222502d+00,     0.1406532597155259d+00,
     *     0.1690047266392679d+00,     0.1903505780647854d+00,
     *     0.2044329400752989d+00,     0.2094821410847278d+00/
c
      data wg(1),wg(2),wg(3),wg(4)/
     *     0.1294849661688697d+00,    0.2797053914892767d+00,
     *     0.3818300505051889d+00,    0.4179591836734694d+00/
c
c
c           list of major variables
c           -----------------------
c
c           centr  - mid point of the interval
c           hlgth  - half-length of the interval
c           absc*  - abscissa
c           fval*  - function value
c           resg   - result of the 7-point gauss formula
c           resk   - result of the 15-point kronrod formula
c           reskh  - approximation to the mean value of f*w over (a,b),
c                    i.e. to i/(b-a)
c
c           machine dependent constants
c           ---------------------------
c
c           epmach is the largest relative spacing.
c           uflow is the smallest positive magnitude.
c
c***first executable statement  dqk15w
      epmach = d1mach(4)
      uflow = d1mach(1)
c
      centr = 0.5d+00*(a+b)
      hlgth = 0.5d+00*(b-a)
      dhlgth = dabs(hlgth)
c
c           compute the 15-point kronrod approximation to the
c           integral, and estimate the error.
c
      fc = f(centr)*w(centr,p1,p2,p3,p4,kp)
      resg = wg(4)*fc
      resk = wgk(8)*fc
      resabs = dabs(resk)
      do 10 j=1,3
        jtw = j*2
        absc = hlgth*xgk(jtw)
        absc1 = centr-absc
        absc2 = centr+absc
        fval1 = f(absc1)*w(absc1,p1,p2,p3,p4,kp)
        fval2 = f(absc2)*w(absc2,p1,p2,p3,p4,kp)
        fv1(jtw) = fval1
        fv2(jtw) = fval2
        fsum = fval1+fval2
        resg = resg+wg(j)*fsum
        resk = resk+wgk(jtw)*fsum
        resabs = resabs+wgk(jtw)*(dabs(fval1)+dabs(fval2))
   10 continue
      do 15 j=1,4
        jtwm1 = j*2-1
        absc = hlgth*xgk(jtwm1)
        absc1 = centr-absc
        absc2 = centr+absc
        fval1 = f(absc1)*w(absc1,p1,p2,p3,p4,kp)
        fval2 = f(absc2)*w(absc2,p1,p2,p3,p4,kp)
        fv1(jtwm1) = fval1
        fv2(jtwm1) = fval2
        fsum = fval1+fval2
        resk = resk+wgk(jtwm1)*fsum
        resabs = resabs+wgk(jtwm1)*(dabs(fval1)+dabs(fval2))
   15 continue
      reskh = resk*0.5d+00
      resasc = wgk(8)*dabs(fc-reskh)
      do 20 j=1,7
        resasc = resasc+wgk(j)*(dabs(fv1(j)-reskh)+dabs(fv2(j)-reskh))
   20 continue
      result = resk*hlgth
      resabs = resabs*dhlgth
      resasc = resasc*dhlgth
      abserr = dabs((resk-resg)*hlgth)
      if(resasc.ne.0.0d+00.and.abserr.ne.0.0d+00)
     *  abserr = resasc*dmin1(0.1d+01,(0.2d+03*abserr/resasc)**1.5d+00)
      if(resabs.gt.uflow/(0.5d+02*epmach)) abserr = dmax1((epmach*
     *  0.5d+02)*resabs,abserr)
      return
      end
      double precision function dqwgtf(x,omega,p2,p3,p4,integr)
c***begin prologue  dqwgtf
c***refer to   dqk15w
c***routines called  (none)
c***revision date 810101   (yymmdd)
c***keywords  cos or sin in weight function
c***author  piessens,robert, appl. math. & progr. div. - k.u.leuven
c           de doncker,elise,appl. math. * progr. div. - k.u.leuven
c***end prologue  dqwgtf
c
      double precision dcos,dsin,omega,omx,p2,p3,p4,x
      integer integr
c***first executable statement  dqwgtf
      omx = omega*x
      go to(10,20),integr
   10 dqwgtf = dcos(omx)
      go to 30
   20 dqwgtf = dsin(omx)
   30 return
      end

      subroutine dqagie(f,bound,inf,epsabs,epsrel,limit,result,abserr,
     *   neval,ier,alist,blist,rlist,elist,iord,last)
c***begin prologue  dqagie
c***date written   800101   (yymmdd)
c***revision date  830518   (yymmdd)
c***category no.  h2a3a1,h2a4a1
c***keywords  automatic integrator, infinite intervals,
c             general-purpose, transformation, extrapolation,
c             globally adaptive
c***author  piessens,robert,appl. math & progr. div - k.u.leuven
c           de doncker,elise,appl. math & progr. div - k.u.leuven
c***purpose  the routine calculates an approximation result to a given
c            integral   i = integral of f over (bound,+infinity)
c            or i = integral of f over (-infinity,bound)
c            or i = integral of f over (-infinity,+infinity),
c            hopefully satisfying following claim for accuracy
c            abs(i-result).le.max(epsabs,epsrel*abs(i))
c***description
c
c integration over infinite intervals
c standard fortran subroutine
c
c            f      - double precision
c                     function subprogram defining the integrand
c                     function f(x). the actual name for f needs to be
c                     declared e x t e r n a l in the driver program.
c
c            bound  - double precision
c                     finite bound of integration range
c                     (has no meaning if interval is doubly-infinite)
c
c            inf    - double precision
c                     indicating the kind of integration range involved
c                     inf = 1 corresponds to  (bound,+infinity),
c                     inf = -1            to  (-infinity,bound),
c                     inf = 2             to (-infinity,+infinity).
c
c            epsabs - double precision
c                     absolute accuracy requested
c            epsrel - double precision
c                     relative accuracy requested
c                     if  epsabs.le.0
c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
c                     the routine will end with ier = 6.
c
c            limit  - integer
c                     gives an upper bound on the number of subintervals
c                     in the partition of (a,b), limit.ge.1
c
c         on return
c            result - double precision
c                     approximation to the integral
c
c            abserr - double precision
c                     estimate of the modulus of the absolute error,
c                     which should equal or exceed abs(i-result)
c
c            neval  - integer
c                     number of integrand evaluations
c
c            ier    - integer
c                     ier = 0 normal and reliable termination of the
c                             routine. it is assumed that the requested
c                             accuracy has been achieved.
c                   - ier.gt.0 abnormal termination of the routine. the
c                             estimates for result and error are less
c                             reliable. it is assumed that the requested
c                             accuracy has not been achieved.
c            error messages
c                     ier = 1 maximum number of subdivisions allowed
c                             has been achieved. one can allow more
c                             subdivisions by increasing the value of
c                             limit (and taking the according dimension
c                             adjustments into account). however,if
c                             this yields no improvement it is advised
c                             to analyze the integrand in order to
c                             determine the integration difficulties.
c                             if the position of a local difficulty can
c                             be determined (e.g. singularity,
c                             discontinuity within the interval) one
c                             will probably gain from splitting up the
c                             interval at this point and calling the
c                             integrator on the subranges. if possible,
c                             an appropriate special-purpose integrator
c                             should be used, which is designed for
c                             handling the type of difficulty involved.
c                         = 2 the occurrence of roundoff error is
c                             detected, which prevents the requested
c                             tolerance from being achieved.
c                             the error may be under-estimated.
c                         = 3 extremely bad integrand behaviour occurs
c                             at some points of the integration
c                             interval.
c                         = 4 the algorithm does not converge.
c                             roundoff error is detected in the
c                             extrapolation table.
c                             it is assumed that the requested tolerance
c                             cannot be achieved, and that the returned
c                             result is the best which can be obtained.
c                         = 5 the integral is probably divergent, or
c                             slowly convergent. it must be noted that
c                             divergence can occur with any other value
c                             of ier.
c                         = 6 the input is invalid, because
c                             (epsabs.le.0 and
c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
c                             result, abserr, neval, last, rlist(1),
c                             elist(1) and iord(1) are set to zero.
c                             alist(1) and blist(1) are set to 0
c                             and 1 respectively.
c
c            alist  - double precision
c                     vector of dimension at least limit, the first
c                      last  elements of which are the left
c                     end points of the subintervals in the partition
c                     of the transformed integration range (0,1).
c
c            blist  - double precision
c                     vector of dimension at least limit, the first
c                      last  elements of which are the right
c                     end points of the subintervals in the partition
c                     of the transformed integration range (0,1).
c
c            rlist  - double precision
c                     vector of dimension at least limit, the first
c                      last  elements of which are the integral
c                     approximations on the subintervals
c
c            elist  - double precision
c                     vector of dimension at least limit,  the first
c                     last elements of which are the moduli of the
c                     absolute error estimates on the subintervals
c
c            iord   - integer
c                     vector of dimension limit, the first k
c                     elements of which are pointers to the
c                     error estimates over the subintervals,
c                     such that elist(iord(1)), ..., elist(iord(k))
c                     form a decreasing sequence, with k = last
c                     if last.le.(limit/2+2), and k = limit+1-last
c                     otherwise
c
c            last   - integer
c                     number of subintervals actually produced
c                     in the subdivision process
c
c***references  (none)
c***routines called  d1mach,dqelg,dqk15i,dqpsrt
c***end prologue  dqagie
      double precision abseps,abserr,alist,area,area1,area12,area2,a1,
     *  a2,blist,boun,bound,b1,b2,correc,dabs,defabs,defab1,defab2,
     *  dmax1,dres,d1mach,elist,epmach,epsabs,epsrel,erlarg,erlast,
     *  errbnd,errmax,error1,error2,erro12,errsum,ertest,f,oflow,resabs,
     *  reseps,result,res3la,rlist,rlist2,small,uflow
      integer id,ier,ierro,inf,iord,iroff1,iroff2,iroff3,jupbnd,k,ksgn,
     *  ktmin,last,limit,maxerr,neval,nres,nrmax,numrl2
      logical extrap,noext
c
      dimension alist(limit),blist(limit),elist(limit),iord(limit),
     *  res3la(3),rlist(limit),rlist2(52)
c
      external f
c
c            the dimension of rlist2 is determined by the value of
c            limexp in subroutine dqelg.
c
c
c            list of major variables
c            -----------------------
c
c           alist     - list of left end points of all subintervals
c                       considered up to now
c           blist     - list of right end points of all subintervals
c                       considered up to now
c           rlist(i)  - approximation to the integral over
c                       (alist(i),blist(i))
c           rlist2    - array of dimension at least (limexp+2),
c                       containing the part of the epsilon table
c                       wich is still needed for further computations
c           elist(i)  - error estimate applying to rlist(i)
c           maxerr    - pointer to the interval with largest error
c                       estimate
c           errmax    - elist(maxerr)
c           erlast    - error on the interval currently subdivided
c                       (before that subdivision has taken place)
c           area      - sum of the integrals over the subintervals
c           errsum    - sum of the errors over the subintervals
c           errbnd    - requested accuracy max(epsabs,epsrel*
c                       abs(result))
c           *****1    - variable for the left subinterval
c           *****2    - variable for the right subinterval
c           last      - index for subdivision
c           nres      - number of calls to the extrapolation routine
c           numrl2    - number of elements currently in rlist2. if an
c                       appropriate approximation to the compounded
c                       integral has been obtained, it is put in
c                       rlist2(numrl2) after numrl2 has been increased
c                       by one.
c           small     - length of the smallest interval considered up
c                       to now, multiplied by 1.5
c           erlarg    - sum of the errors over the intervals larger
c                       than the smallest interval considered up to now
c           extrap    - logical variable denoting that the routine
c                       is attempting to perform extrapolation. i.e.
c                       before subdividing the smallest interval we
c                       try to decrease the value of erlarg.
c           noext     - logical variable denoting that extrapolation
c                       is no longer allowed (true-value)
c
c            machine dependent constants
c            ---------------------------
c
c           epmach is the largest relative spacing.
c           uflow is the smallest positive magnitude.
c           oflow is the largest positive magnitude.
c
c***first executable statement  dqagie
       epmach = d1mach(4)
c
c           test on validity of parameters
c           -----------------------------
c
      ier = 0
      neval = 0
      last = 0
      result = 0.0d+00
      abserr = 0.0d+00
      alist(1) = 0.0d+00
      blist(1) = 0.1d+01
      rlist(1) = 0.0d+00
      elist(1) = 0.0d+00
      iord(1) = 0
      if(epsabs.le.0.0d+00.and.epsrel.lt.dmax1(0.5d+02*epmach,0.5d-28))
     *  ier = 6
       if(ier.eq.6) go to 999
c
c
c           first approximation to the integral
c           -----------------------------------
c
c           determine the interval to be mapped onto (0,1).
c           if inf = 2 the integral is computed as i = i1+i2, where
c           i1 = integral of f over (-infinity,0),
c           i2 = integral of f over (0,+infinity).
c
      boun = bound
      if(inf.eq.2) boun = 0.0d+00
      call dqk15i(f,boun,inf,0.0d+00,0.1d+01,result,abserr,
     *  defabs,resabs)
c
c           test on accuracy
c
      last = 1
      rlist(1) = result
      elist(1) = abserr
      iord(1) = 1
      dres = dabs(result)
      errbnd = dmax1(epsabs,epsrel*dres)
      if(abserr.le.1.0d+02*epmach*defabs.and.abserr.gt.errbnd) ier = 2
      if(limit.eq.1) ier = 1
      if(ier.ne.0.or.(abserr.le.errbnd.and.abserr.ne.resabs).or.
     *  abserr.eq.0.0d+00) go to 130
c
c           initialization
c           --------------
c
      uflow = d1mach(1)
      oflow = d1mach(2)
      rlist2(1) = result
      errmax = abserr
      maxerr = 1
      area = result
      errsum = abserr
      abserr = oflow
      nrmax = 1
      nres = 0
      ktmin = 0
      numrl2 = 2
      extrap = .false.
      noext = .false.
      ierro = 0
      iroff1 = 0
      iroff2 = 0
      iroff3 = 0
      ksgn = -1
      if(dres.ge.(0.1d+01-0.5d+02*epmach)*defabs) ksgn = 1
c
c           main do-loop
c           ------------
c
      do 90 last = 2,limit
c
c           bisect the subinterval with nrmax-th largest error estimate.
c
        a1 = alist(maxerr)
        b1 = 0.5d+00*(alist(maxerr)+blist(maxerr))
        a2 = b1
        b2 = blist(maxerr)
        erlast = errmax
        call dqk15i(f,boun,inf,a1,b1,area1,error1,resabs,defab1)
        call dqk15i(f,boun,inf,a2,b2,area2,error2,resabs,defab2)
c
c           improve previous approximations to integral
c           and error and test for accuracy.
c
        area12 = area1+area2
        erro12 = error1+error2
        errsum = errsum+erro12-errmax
        area = area+area12-rlist(maxerr)
        if(defab1.eq.error1.or.defab2.eq.error2)go to 15
        if(dabs(rlist(maxerr)-area12).gt.0.1d-04*dabs(area12)
     *  .or.erro12.lt.0.99d+00*errmax) go to 10
        if(extrap) iroff2 = iroff2+1
        if(.not.extrap) iroff1 = iroff1+1
   10   if(last.gt.10.and.erro12.gt.errmax) iroff3 = iroff3+1
   15   rlist(maxerr) = area1
        rlist(last) = area2
        errbnd = dmax1(epsabs,epsrel*dabs(area))
c
c           test for roundoff error and eventually set error flag.
c
        if(iroff1+iroff2.ge.10.or.iroff3.ge.20) ier = 2
        if(iroff2.ge.5) ierro = 3
c
c           set error flag in the case that the number of
c           subintervals equals limit.
c
        if(last.eq.limit) ier = 1
c
c           set error flag in the case of bad integrand behaviour
c           at some points of the integration range.
c
        if(dmax1(dabs(a1),dabs(b2)).le.(0.1d+01+0.1d+03*epmach)*
     *  (dabs(a2)+0.1d+04*uflow)) ier = 4
c
c           append the newly-created intervals to the list.
c
        if(error2.gt.error1) go to 20
        alist(last) = a2
        blist(maxerr) = b1
        blist(last) = b2
        elist(maxerr) = error1
        elist(last) = error2
        go to 30
   20   alist(maxerr) = a2
        alist(last) = a1
        blist(last) = b1
        rlist(maxerr) = area2
        rlist(last) = area1
        elist(maxerr) = error2
        elist(last) = error1
c
c           call subroutine dqpsrt to maintain the descending ordering
c           in the list of error estimates and select the subinterval
c           with nrmax-th largest error estimate (to be bisected next).
c
   30   call dqpsrt(limit,last,maxerr,errmax,elist,iord,nrmax)
        if(errsum.le.errbnd) go to 115
        if(ier.ne.0) go to 100
        if(last.eq.2) go to 80
        if(noext) go to 90
        erlarg = erlarg-erlast
        if(dabs(b1-a1).gt.small) erlarg = erlarg+erro12
        if(extrap) go to 40
c
c           test whether the interval to be bisected next is the
c           smallest interval.
c
        if(dabs(blist(maxerr)-alist(maxerr)).gt.small) go to 90
        extrap = .true.
        nrmax = 2
   40   if(ierro.eq.3.or.erlarg.le.ertest) go to 60
c
c           the smallest interval has the largest error.
c           before bisecting decrease the sum of the errors over the
c           larger intervals (erlarg) and perform extrapolation.
c
        id = nrmax
        jupbnd = last
        if(last.gt.(2+limit/2)) jupbnd = limit+3-last
        do 50 k = id,jupbnd
          maxerr = iord(nrmax)
          errmax = elist(maxerr)
          if(dabs(blist(maxerr)-alist(maxerr)).gt.small) go to 90
          nrmax = nrmax+1
   50   continue
c
c           perform extrapolation.
c
   60   numrl2 = numrl2+1
        rlist2(numrl2) = area
        call dqelg(numrl2,rlist2,reseps,abseps,res3la,nres)
        ktmin = ktmin+1
        if(ktmin.gt.5.and.abserr.lt.0.1d-02*errsum) ier = 5
        if(abseps.ge.abserr) go to 70
        ktmin = 0
        abserr = abseps
        result = reseps
        correc = erlarg
        ertest = dmax1(epsabs,epsrel*dabs(reseps))
        if(abserr.le.ertest) go to 100
c
c            prepare bisection of the smallest interval.
c
   70   if(numrl2.eq.1) noext = .true.
        if(ier.eq.5) go to 100
        maxerr = iord(1)
        errmax = elist(maxerr)
        nrmax = 1
        extrap = .false.
        small = small*0.5d+00
        erlarg = errsum
        go to 90
   80   small = 0.375d+00
        erlarg = errsum
        ertest = errbnd
        rlist2(2) = area
   90 continue
c
c           set final result and error estimate.
c           ------------------------------------
c
  100 if(abserr.eq.oflow) go to 115
      if((ier+ierro).eq.0) go to 110
      if(ierro.eq.3) abserr = abserr+correc
      if(ier.eq.0) ier = 3
      if(result.ne.0.0d+00.and.area.ne.0.0d+00)go to 105
      if(abserr.gt.errsum)go to 115
      if(area.eq.0.0d+00) go to 130
      go to 110
  105 if(abserr/dabs(result).gt.errsum/dabs(area))go to 115
c
c           test on divergence
c
  110 if(ksgn.eq.(-1).and.dmax1(dabs(result),dabs(area)).le.
     * defabs*0.1d-01) go to 130
      if(0.1d-01.gt.(result/area).or.(result/area).gt.0.1d+03.
     *or.errsum.gt.dabs(area)) ier = 6
      go to 130
c
c           compute global integral sum.
c
  115 result = 0.0d+00
      do 120 k = 1,last
        result = result+rlist(k)
  120 continue
      abserr = errsum
  130 neval = 30*last-15
      if(inf.eq.2) neval = 2*neval
      if(ier.gt.2) ier=ier-1
  999 return
      end
      subroutine dqelg(n,epstab,result,abserr,res3la,nres)
c***begin prologue  dqelg
c***refer to  dqagie,dqagoe,dqagpe,dqagse
c***routines called  d1mach
c***revision date  830518   (yymmdd)
c***keywords  epsilon algorithm, convergence acceleration,
c             extrapolation
c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
c           de doncker,elise,appl. math & progr. div. - k.u.leuven
c***purpose  the routine determines the limit of a given sequence of
c            approximations, by means of the epsilon algorithm of
c            p.wynn. an estimate of the absolute error is also given.
c            the condensed epsilon table is computed. only those
c            elements needed for the computation of the next diagonal
c            are preserved.
c***description
c
c           epsilon algorithm
c           standard fortran subroutine
c           double precision version
c
c           parameters
c              n      - integer
c                       epstab(n) contains the new element in the
c                       first column of the epsilon table.
c
c              epstab - double precision
c                       vector of dimension 52 containing the elements
c                       of the two lower diagonals of the triangular
c                       epsilon table. the elements are numbered
c                       starting at the right-hand corner of the
c                       triangle.
c
c              result - double precision
c                       resulting approximation to the integral
c
c              abserr - double precision
c                       estimate of the absolute error computed from
c                       result and the 3 previous results
c
c              res3la - double precision
c                       vector of dimension 3 containing the last 3
c                       results
c
c              nres   - integer
c                       number of calls to the routine
c                       (should be zero at first call)
c
c***end prologue  dqelg
c
      double precision abserr,dabs,delta1,delta2,delta3,dmax1,d1mach,
     *  epmach,epsinf,epstab,error,err1,err2,err3,e0,e1,e1abs,e2,e3,
     *  oflow,res,result,res3la,ss,tol1,tol2,tol3
      integer i,ib,ib2,ie,indx,k1,k2,k3,limexp,n,newelm,nres,num
      dimension epstab(52),res3la(3)
c
c           list of major variables
c           -----------------------
c
c           e0     - the 4 elements on which the computation of a new
c           e1       element in the epsilon table is based
c           e2
c           e3                 e0
c                        e3    e1    new
c                              e2
c           newelm - number of elements to be computed in the new
c                    diagonal
c           error  - error = abs(e1-e0)+abs(e2-e1)+abs(new-e2)
c           result - the element in the new diagonal with least value
c                    of error
c
c           machine dependent constants
c           ---------------------------
c
c           epmach is the largest relative spacing.
c           oflow is the largest positive magnitude.
c           limexp is the maximum number of elements the epsilon
c           table can contain. if this number is reached, the upper
c           diagonal of the epsilon table is deleted.
c
c***first executable statement  dqelg
      epmach = d1mach(4)
      oflow = d1mach(2)
      nres = nres+1
      abserr = oflow
      result = epstab(n)
      if(n.lt.3) go to 100
      limexp = 50
      epstab(n+2) = epstab(n)
      newelm = (n-1)/2
      epstab(n) = oflow
      num = n
      k1 = n
      do 40 i = 1,newelm
        k2 = k1-1
        k3 = k1-2
        res = epstab(k1+2)
        e0 = epstab(k3)
        e1 = epstab(k2)
        e2 = res
        e1abs = dabs(e1)
        delta2 = e2-e1
        err2 = dabs(delta2)
        tol2 = dmax1(dabs(e2),e1abs)*epmach
        delta3 = e1-e0
        err3 = dabs(delta3)
        tol3 = dmax1(e1abs,dabs(e0))*epmach
        if(err2.gt.tol2.or.err3.gt.tol3) go to 10
c
c           if e0, e1 and e2 are equal to within machine
c           accuracy, convergence is assumed.
c           result = e2
c           abserr = abs(e1-e0)+abs(e2-e1)
c
        result = res
        abserr = err2+err3
c ***jump out of do-loop
        go to 100
   10   e3 = epstab(k1)
        epstab(k1) = e1
        delta1 = e1-e3
        err1 = dabs(delta1)
        tol1 = dmax1(e1abs,dabs(e3))*epmach
c
c           if two elements are very close to each other, omit
c           a part of the table by adjusting the value of n
c
        if(err1.le.tol1.or.err2.le.tol2.or.err3.le.tol3) go to 20
        ss = 0.1d+01/delta1+0.1d+01/delta2-0.1d+01/delta3
        epsinf = dabs(ss*e1)
c
c           test to detect irregular behaviour in the table, and
c           eventually omit a part of the table adjusting the value
c           of n.
c
        if(epsinf.gt.0.1d-03) go to 30
   20   n = i+i-1
c ***jump out of do-loop
        go to 50
c
c           compute a new element and eventually adjust
c           the value of result.
c
   30   res = e1+0.1d+01/ss
        epstab(k1) = res
        k1 = k1-2
        error = err2+dabs(res-e2)+err3
        if(error.gt.abserr) go to 40
        abserr = error
        result = res
   40 continue
c
c           shift the table.
c
   50 if(n.eq.limexp) n = 2*(limexp/2)-1
      ib = 1
      if((num/2)*2.eq.num) ib = 2
      ie = newelm+1
      do 60 i=1,ie
        ib2 = ib+2
        epstab(ib) = epstab(ib2)
        ib = ib2
   60 continue
      if(num.eq.n) go to 80
      indx = num-n+1
      do 70 i = 1,n
        epstab(i)= epstab(indx)
        indx = indx+1
   70 continue
   80 if(nres.ge.4) go to 90
      res3la(nres) = result
      abserr = oflow
      go to 100
c
c           compute error estimate
c
   90 abserr = dabs(result-res3la(3))+dabs(result-res3la(2))
     *  +dabs(result-res3la(1))
      res3la(1) = res3la(2)
      res3la(2) = res3la(3)
      res3la(3) = result
  100 abserr = dmax1(abserr,0.5d+01*epmach*dabs(result))
      return
      end
      subroutine dqk15i(f,boun,inf,a,b,result,abserr,resabs,resasc)
c***begin prologue  dqk15i
c***date written   800101   (yymmdd)
c***revision date  830518   (yymmdd)
c***category no.  h2a3a2,h2a4a2
c***keywords  15-point transformed gauss-kronrod rules
c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
c***purpose  the original (infinite integration range is mapped
c            onto the interval (0,1) and (a,b) is a part of (0,1).
c            it is the purpose to compute
c            i = integral of transformed integrand over (a,b),
c            j = integral of abs(transformed integrand) over (a,b).
c***description
c
c           integration rule
c           standard fortran subroutine
c           double precision version
c
c           parameters
c            on entry
c              f      - double precision
c                       fuction subprogram defining the integrand
c                       function f(x). the actual name for f needs to be
c                       declared e x t e r n a l in the calling program.
c
c              boun   - double precision
c                       finite bound of original integration
c                       range (set to zero if inf = +2)
c
c              inf    - integer
c                       if inf = -1, the original interval is
c                                   (-infinity,bound),
c                       if inf = +1, the original interval is
c                                   (bound,+infinity),
c                       if inf = +2, the original interval is
c                                   (-infinity,+infinity) and
c                       the integral is computed as the sum of two
c                       integrals, one over (-infinity,0) and one over
c                       (0,+infinity).
c
c              a      - double precision
c                       lower limit for integration over subrange
c                       of (0,1)
c
c              b      - double precision
c                       upper limit for integration over subrange
c                       of (0,1)
c
c            on return
c              result - double precision
c                       approximation to the integral i
c                       result is computed by applying the 15-point
c                       kronrod rule(resk) obtained by optimal addition
c                       of abscissae to the 7-point gauss rule(resg).
c
c              abserr - double precision
c                       estimate of the modulus of the absolute error,
c                       which should equal or exceed abs(i-result)
c
c              resabs - double precision
c                       approximation to the integral j
c
c              resasc - double precision
c                       approximation to the integral of
c                       abs((transformed integrand)-i/(b-a)) over (a,b)
c
c***references  (none)
c***routines called  d1mach
c***end prologue  dqk15i
c
      double precision a,absc,absc1,absc2,abserr,b,boun,centr,dabs,dinf,
     *  dmax1,dmin1,d1mach,epmach,f,fc,fsum,fval1,fval2,fv1,fv2,hlgth,
     *  resabs,resasc,resg,resk,reskh,result,tabsc1,tabsc2,uflow,wg,wgk,
     *  xgk
      integer inf,j
      external f
c
      dimension fv1(7),fv2(7),xgk(8),wgk(8),wg(8)
c
c           the abscissae and weights are supplied for the interval
c           (-1,1).  because of symmetry only the positive abscissae and
c           their corresponding weights are given.
c
c           xgk    - abscissae of the 15-point kronrod rule
c                    xgk(2), xgk(4), ... abscissae of the 7-point
c                    gauss rule
c                    xgk(1), xgk(3), ...  abscissae which are optimally
c                    added to the 7-point gauss rule
c
c           wgk    - weights of the 15-point kronrod rule
c
c           wg     - weights of the 7-point gauss rule, corresponding
c                    to the abscissae xgk(2), xgk(4), ...
c                    wg(1), wg(3), ... are set to zero.
c
      data wg(1) / 0.0d0 /
      data wg(2) / 0.1294849661 6886969327 0611432679 082d0 /
      data wg(3) / 0.0d0 /
      data wg(4) / 0.2797053914 8927666790 1467771423 780d0 /
      data wg(5) / 0.0d0 /
      data wg(6) / 0.3818300505 0511894495 0369775488 975d0 /
      data wg(7) / 0.0d0 /
      data wg(8) / 0.4179591836 7346938775 5102040816 327d0 /
c
      data xgk(1) / 0.9914553711 2081263920 6854697526 329d0 /
      data xgk(2) / 0.9491079123 4275852452 6189684047 851d0 /
      data xgk(3) / 0.8648644233 5976907278 9712788640 926d0 /
      data xgk(4) / 0.7415311855 9939443986 3864773280 788d0 /
      data xgk(5) / 0.5860872354 6769113029 4144838258 730d0 /
      data xgk(6) / 0.4058451513 7739716690 6606412076 961d0 /
      data xgk(7) / 0.2077849550 0789846760 0689403773 245d0 /
      data xgk(8) / 0.0000000000 0000000000 0000000000 000d0 /
c
      data wgk(1) / 0.0229353220 1052922496 3732008058 970d0 /
      data wgk(2) / 0.0630920926 2997855329 0700663189 204d0 /
      data wgk(3) / 0.1047900103 2225018383 9876322541 518d0 /
      data wgk(4) / 0.1406532597 1552591874 5189590510 238d0 /
      data wgk(5) / 0.1690047266 3926790282 6583426598 550d0 /
      data wgk(6) / 0.1903505780 6478540991 3256402421 014d0 /
      data wgk(7) / 0.2044329400 7529889241 4161999234 649d0 /
      data wgk(8) / 0.2094821410 8472782801 2999174891 714d0 /
c
c
c           list of major variables
c           -----------------------
c
c           centr  - mid point of the interval
c           hlgth  - half-length of the interval
c           absc*  - abscissa
c           tabsc* - transformed abscissa
c           fval*  - function value
c           resg   - result of the 7-point gauss formula
c           resk   - result of the 15-point kronrod formula
c           reskh  - approximation to the mean value of the transformed
c                    integrand over (a,b), i.e. to i/(b-a)
c
c           machine dependent constants
c           ---------------------------
c
c           epmach is the largest relative spacing.
c           uflow is the smallest positive magnitude.
c
c***first executable statement  dqk15i
      epmach = d1mach(4)
      uflow = d1mach(1)
      dinf = min0(1,inf)
c
      centr = 0.5d+00*(a+b)
      hlgth = 0.5d+00*(b-a)
      tabsc1 = boun+dinf*(0.1d+01-centr)/centr
      fval1 = f(tabsc1)
      if(inf.eq.2) fval1 = fval1+f(-tabsc1)
      fc = (fval1/centr)/centr
c
c           compute the 15-point kronrod approximation to
c           the integral, and estimate the error.
c
      resg = wg(8)*fc
      resk = wgk(8)*fc
      resabs = dabs(resk)
      do 10 j=1,7
        absc = hlgth*xgk(j)
        absc1 = centr-absc
        absc2 = centr+absc
        tabsc1 = boun+dinf*(0.1d+01-absc1)/absc1
        tabsc2 = boun+dinf*(0.1d+01-absc2)/absc2
        fval1 = f(tabsc1)
        fval2 = f(tabsc2)
        if(inf.eq.2) fval1 = fval1+f(-tabsc1)
        if(inf.eq.2) fval2 = fval2+f(-tabsc2)
        fval1 = (fval1/absc1)/absc1
        fval2 = (fval2/absc2)/absc2
        fv1(j) = fval1
        fv2(j) = fval2
        fsum = fval1+fval2
        resg = resg+wg(j)*fsum
        resk = resk+wgk(j)*fsum
        resabs = resabs+wgk(j)*(dabs(fval1)+dabs(fval2))
   10 continue
      reskh = resk*0.5d+00
      resasc = wgk(8)*dabs(fc-reskh)
      do 20 j=1,7
        resasc = resasc+wgk(j)*(dabs(fv1(j)-reskh)+dabs(fv2(j)-reskh))
   20 continue
      result = resk*hlgth
      resasc = resasc*hlgth
      resabs = resabs*hlgth
      abserr = dabs((resk-resg)*hlgth)
      if(resasc.ne.0.0d+00.and.abserr.ne.0.d0) abserr = resasc*
     * dmin1(0.1d+01,(0.2d+03*abserr/resasc)**1.5d+00)
      if(resabs.gt.uflow/(0.5d+02*epmach)) abserr = dmax1
     * ((epmach*0.5d+02)*resabs,abserr)
      return
      end
      subroutine dqpsrt(limit,last,maxerr,ermax,elist,iord,nrmax)
c***begin prologue  dqpsrt
c***refer to  dqage,dqagie,dqagpe,dqawse
c***routines called  (none)
c***revision date  810101   (yymmdd)
c***keywords  sequential sorting
c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
c***purpose  this routine maintains the descending ordering in the
c            list of the local error estimated resulting from the
c            interval subdivision process. at each call two error
c            estimates are inserted using the sequential search
c            method, top-down for the largest error estimate and
c            bottom-up for the smallest error estimate.
c***description
c
c           ordering routine
c           standard fortran subroutine
c           double precision version
c
c           parameters (meaning at output)
c              limit  - integer
c                       maximum number of error estimates the list
c                       can contain
c
c              last   - integer
c                       number of error estimates currently in the list
c
c              maxerr - integer
c                       maxerr points to the nrmax-th largest error
c                       estimate currently in the list
c
c              ermax  - double precision
c                       nrmax-th largest error estimate
c                       ermax = elist(maxerr)
c
c              elist  - double precision
c                       vector of dimension last containing
c                       the error estimates
c
c              iord   - integer
c                       vector of dimension last, the first k elements
c                       of which contain pointers to the error
c                       estimates, such that
c                       elist(iord(1)),...,  elist(iord(k))
c                       form a decreasing sequence, with
c                       k = last if last.le.(limit/2+2), and
c                       k = limit+1-last otherwise
c
c              nrmax  - integer
c                       maxerr = iord(nrmax)
c
c***end prologue  dqpsrt
c
      double precision elist,ermax,errmax,errmin
      integer i,ibeg,ido,iord,isucc,j,jbnd,jupbn,k,last,limit,maxerr,
     *  nrmax
      dimension elist(last),iord(last)
c
c           check whether the list contains more than
c           two error estimates.
c
c***first executable statement  dqpsrt
      if(last.gt.2) go to 10
      iord(1) = 1
      iord(2) = 2
      go to 90
c
c           this part of the routine is only executed if, due to a
c           difficult integrand, subdivision increased the error
c           estimate. in the normal case the insert procedure should
c           start after the nrmax-th largest error estimate.
c
   10 errmax = elist(maxerr)
      if(nrmax.eq.1) go to 30
      ido = nrmax-1
      do 20 i = 1,ido
        isucc = iord(nrmax-1)
c ***jump out of do-loop
        if(errmax.le.elist(isucc)) go to 30
        iord(nrmax) = isucc
        nrmax = nrmax-1
   20    continue
c
c           compute the number of elements in the list to be maintained
c           in descending order. this number depends on the number of
c           subdivisions still allowed.
c
   30 jupbn = last
      if(last.gt.(limit/2+2)) jupbn = limit+3-last
      errmin = elist(last)
c
c           insert errmax by traversing the list top-down,
c           starting comparison from the element elist(iord(nrmax+1)).
c
      jbnd = jupbn-1
      ibeg = nrmax+1
      if(ibeg.gt.jbnd) go to 50
      do 40 i=ibeg,jbnd
        isucc = iord(i)
c ***jump out of do-loop
        if(errmax.ge.elist(isucc)) go to 60
        iord(i-1) = isucc
   40 continue
   50 iord(jbnd) = maxerr
      iord(jupbn) = last
      go to 90
c
c           insert errmin by traversing the list bottom-up.
c
   60 iord(i-1) = maxerr
      k = jbnd
      do 70 j=i,jbnd
        isucc = iord(k)
c ***jump out of do-loop
        if(errmin.lt.elist(isucc)) go to 80
        iord(k+1) = isucc
        k = k-1
   70 continue
      iord(i) = last
      go to 90
   80 iord(k+1) = last
c
c           set maxerr and ermax.
c
   90 maxerr = iord(nrmax)
      ermax = elist(maxerr)
      return
      end
      
      
